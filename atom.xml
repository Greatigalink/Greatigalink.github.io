<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-21T08:20:50.701Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Greatiga</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blender的洋面烘焙贴图怎么都一样呢？</title>
    <link href="http://example.com/2024/04/12/blender/%E6%B4%8B%E9%9D%A2%E7%83%98%E7%84%99%E8%B4%B4%E5%9B%BE%E4%B8%BA%E4%BD%95%E9%83%BD%E4%B8%80%E6%A0%B7/"/>
    <id>http://example.com/2024/04/12/blender/%E6%B4%8B%E9%9D%A2%E7%83%98%E7%84%99%E8%B4%B4%E5%9B%BE%E4%B8%BA%E4%BD%95%E9%83%BD%E4%B8%80%E6%A0%B7/</id>
    <published>2024-04-12T14:38:32.000Z</published>
    <updated>2024-04-21T08:20:50.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><blockquote><p>今天使用blender洋面修改器制作海洋。制作完毕后，准备使用修改器自带的烘焙功能进行贴图烘焙，以节省后续的渲染性能。</p></blockquote><blockquote><p>但是却发现，渲染出来的帧数，结果都一样。</p></blockquote><blockquote><p>并且进一步发现，当前的时间线停留在第几帧，那么渲染出来的所有帧数就都是该帧。</p></blockquote><blockquote><p>这也太离谱了，总不能上百帧，然后一帧一帧的去点击渲染吧？</p></blockquote><span id="more"></span><h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><ul><li>怀疑是时间线问题，重新制作所有关键帧 – 不行，依然存在</li><li>怀疑是烘焙结果的保存问题，重新指定贴图保存文件 – 不行，依然如此</li><li>怀疑是内存中存在太多数据发生错误，重新启动blender，甚至重启电脑 – 不行，依然如此</li><li>怀疑是修改器某项参数的问题，测试之后发现了问题所在。</li></ul><h2 id="发现问题点"><a href="#发现问题点" class="headerlink" title="发现问题点"></a>发现问题点</h2><ul><li><p>突然想起来，一开始制作海洋，只使用了洋面修改器的时间功能来做关键帧，这时候的渲染是正常的。</p></li><li><p>但是后来将缩放也加入了动画关键帧，然后问题貌似就有了？</p></li><li><p>马上进行验证，发现果真如此：添加了“缩放”关键帧之后，点击烘焙，烘焙出的贴图明度都和当前帧的明度一样。无论你划定了1-100帧还是多少，所有结果都是当前帧的那幅exr贴图的明度，这就好导致如果你停留在第一帧（也就是没有内容初始化全黑的帧），那么剩下的所有帧都会采用这个“全黑”的明度，结果也都全身黑色的了。</p></li><li><p>删除“缩放”的关键帧后，在此进行烘焙，结果果然正常了。每一帧都是不一样的内容和明度，都是根据海洋实时计算得来的。</p></li><li><p>在波浪层中单独使用翻滚之后，发现翻滚并没有这样的问题。</p></li><li><p>那为什么只有“缩放”存在这样的问题呢？</p></li></ul><h2 id="进一步排查详细原因"><a href="#进一步排查详细原因" class="headerlink" title="进一步排查详细原因"></a>进一步排查详细原因</h2><ul><li>仔细研究贴图，可以发现，贴图的形状及颜色明度，是由洋面修改器各项参数决定的。比如下面几个重点：</li><li>“缩放”值的高低，决定了烘焙出的贴图的明暗，简而言之，缩放值越高那么贴图越明亮，反之越暗直至全黑。</li><li>“时间值”和“翻滚度”决定的是贴图的内容形状。这一点是正常渲染的，每一帧都不一样。</li><li>然而，神奇的是，blender洋面修改器在进行烘焙时，并非实时计算每一帧“缩放值”对应的明度，并非每一帧都给予它正确的明暗。</li><li>相反，blender是直接使用当前时间线所在帧的缩放值大小（也就是当前帧明暗大小），直接套用在最终所有烘焙帧上。这就导致最终结果的所有帧明暗都是一样，没有区分。而如果你刚好停留在时间线第1帧，也就是缩放值为0（明度最低，即全黑），那么最终所有结果都是黑的。相反，如果你停留在结束帧，缩放值为动画中最高值（也就是最明亮），那么所有帧都是最亮的。</li><li>所以说太奇葩了。</li></ul><h1 id="尝试解决问题"><a href="#尝试解决问题" class="headerlink" title="尝试解决问题"></a>尝试解决问题</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题发现&quot;&gt;&lt;a href=&quot;#问题发现&quot; class=&quot;headerlink&quot; title=&quot;问题发现&quot;&gt;&lt;/a&gt;问题发现&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天使用blender洋面修改器制作海洋。制作完毕后，准备使用修改器自带的烘焙功能进行贴图烘焙，以节省后续的渲染性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;但是却发现，渲染出来的帧数，结果都一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;并且进一步发现，当前的时间线停留在第几帧，那么渲染出来的所有帧数就都是该帧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这也太离谱了，总不能上百帧，然后一帧一帧的去点击渲染吧？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Blender" scheme="http://example.com/categories/Blender/"/>
    
    
    <category term="三维建模" scheme="http://example.com/tags/%E4%B8%89%E7%BB%B4%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="Blender" scheme="http://example.com/tags/Blender/"/>
    
  </entry>
  
  <entry>
    <title>Canvas学习之变换</title>
    <link href="http://example.com/2022/07/26/html/canvas_transform/"/>
    <id>http://example.com/2022/07/26/html/canvas_transform/</id>
    <published>2022-07-26T01:30:07.000Z</published>
    <updated>2022-08-05T08:24:10.630Z</updated>
    
    <content type="html"><![CDATA[<ul><li>旋转问题：计算相对变化量并改变每一个图形坐标。注意旋转绝对值大于 360° 的问题</li><li>放缩问题：计算相对变化量并改变每一个图形坐标</li><li>多条贝塞尔曲线填充不满的问题：开始画第一条曲线的时候用 moveTo 就行了，之后的每一条贝塞尔曲线之间不用 moveTo 了，否则使用 fill 会填不满，会出现几个 moveTo 点形成一个封闭的空白区域。不用担心第二条、第三条等等曲线的起始点问题，因为程序会自动将上一条贝塞尔曲线的终点作为下一条贝塞尔曲线的起点。</li></ul><h1 id="Transform-变换"><a href="#Transform-变换" class="headerlink" title="Transform 变换"></a>Transform 变换</h1><h2 id="1-旋转"><a href="#1-旋转" class="headerlink" title="1 旋转"></a>1 旋转</h2><ul><li>rotate(rangle * Math.PI&#x2F;180)</li><li>仅一个参数，弧度计</li><li>默认以画布原点也就是 (0, 0) 作为旋转原点</li></ul><h3 id="1-1-自定义旋转点"><a href="#1-1-自定义旋转点" class="headerlink" title="1.1 自定义旋转点"></a>1.1 自定义旋转点</h3><blockquote><p>默认的旋转方式都是以画布为原点，这其实满足不了多样的旋转，比如自旋或者以某个点旋转。</p></blockquote><blockquote><p>无论是哪种情况，我们都希望可以让图形围绕自定义的旋转点旋转，因此可以使用 ctx.translate(x, y) 移动至定义的点作为旋转点。</p></blockquote><ul><li><p>但是这样就有一个问题：自定义一个点后，画布的最左上角的点会移动到该点作为原点(0, 0)，那么如果按照此时的坐标系，图形的每个点也会增加相应的水平和垂直位移，就导致图形脱离了屏幕中的相对位置(我们希望的就是图形能以屏幕的任何一个点旋转，但前提条件)</p></li><li><p>所以应该将图形的每个点减去相对变化位置</p></li></ul><h3 id="1-2-重新计算坐标点"><a href="#1-2-重新计算坐标点" class="headerlink" title="1.2 重新计算坐标点"></a>1.2 重新计算坐标点</h3><ul><li>o(x1, y1) 为原始画布原点，一般是 (0, 0)</li><li>o1(x2, y2) 为移动后的画布原点，也就是旋转点</li><li>dx &#x3D; x1 - x2</li><li>dy &#x3D; y1 - y2</li><li>对于每一个图形的点：(X + dx, Y + dy)</li><li>这样就可以保证图形在整个屏幕中的相对位置了</li></ul><h2 id="2-缩放"><a href="#2-缩放" class="headerlink" title="2 缩放"></a>2 缩放</h2><ul><li>scale(x, y)</li></ul><h3 id="2-1-自定义缩放"><a href="#2-1-自定义缩放" class="headerlink" title="2.1 自定义缩放"></a>2.1 自定义缩放</h3><blockquote><p>默认的缩放是将画布扩大或者缩小响应的倍数，这会导致图形的坐标改变，从而脱离屏幕中的原始位置</p></blockquote><blockquote><p>大部分时候我们希望图形原地缩放，或者说缩放后在指定的位置，而不是随着画布缩放而移动到其他地方</p></blockquote><h3 id="2-2-重新计算坐标点"><a href="#2-2-重新计算坐标点" class="headerlink" title="2.2 重新计算坐标点"></a>2.2 重新计算坐标点</h3><ul><li>scale(sx, sy) sx 为水平轴的缩放倍数，sy 为垂直轴的缩放倍数</li><li>O(x1, y1) 为缩放前图形位置，一般是取图形中心位置的点</li><li>O1(x2, y2) 为缩放后随画布移动到的点 <strong>[ 对于 O1 点: x2 &#x3D; x1 * sx, y2 &#x3D; y1 * sy ]</strong></li><li>我们希望缩放前后都是在 O(x1, y1) 点</li><li>dx &#x3D; (x1 - x2) * (1 &#x2F; sx)</li><li>dy &#x3D; (y1 - y2) * (1 &#x2F; sy)</li><li>对于图形上的每一点: (X + dx, Y + dy)</li><li>这样可以保证缩放后的图形依然以 O(x1, y1) 为中心点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;旋转问题：计算相对变化量并改变每一个图形坐标。注意旋转绝对值大于 360° 的问题&lt;/li&gt;
&lt;li&gt;放缩问题：计算相对变化量并改变每一个图形坐标&lt;/li&gt;
&lt;li&gt;多条贝塞尔曲线填充不满的问题：开始画第一条曲线的时候用 moveTo 就行了，之后的每一条贝塞尔</summary>
      
    
    
    
    <category term="Html" scheme="http://example.com/categories/Html/"/>
    
    
    <category term="canvas" scheme="http://example.com/tags/canvas/"/>
    
    <category term="绘图" scheme="http://example.com/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Canvas学习之颜色渐变</title>
    <link href="http://example.com/2022/06/21/html/canvas_gradient/"/>
    <id>http://example.com/2022/06/21/html/canvas_gradient/</id>
    <published>2022-06-21T01:30:07.000Z</published>
    <updated>2022-06-21T07:36:22.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h1><h2 id="1-基本方法"><a href="#1-基本方法" class="headerlink" title="(1) 基本方法"></a>(1) 基本方法</h2><h3 id="createLinearGradient-x1-y1-x2-y2"><a href="#createLinearGradient-x1-y1-x2-y2" class="headerlink" title="createLinearGradient(x1, y1, x2, y2)"></a>createLinearGradient(x1, y1, x2, y2)</h3><ul><li>渐变开始坐标 <strong>(x1, y1)</strong> 到 结束坐标 <strong>(x2, y2)</strong></li><li>该坐标依然以整个页面为坐标系，而不是以填充渐变颜色的容器为基准</li></ul><h3 id="addColorStop-number-colorString"><a href="#addColorStop-number-colorString" class="headerlink" title="addColorStop(number, colorString)"></a>addColorStop(number, colorString)</h3><ul><li>规定颜色渐变-中间-结束的颜色变化</li><li>number 的值为 <strong>0 ~ 1</strong> 之间</li><li>colorString 为颜色值</li></ul><h2 id="2-渐变范围"><a href="#2-渐变范围" class="headerlink" title="(2) 渐变范围"></a>(2) 渐变范围</h2><ul><li>过 <strong>(x1, y1)</strong> 到 <strong>(x2, y2)</strong> 创建一条线段 <strong>AB</strong></li><li>分别过线段两端点画 <strong>垂直于AB</strong> 的直线 <strong>LA、LB</strong></li><li>LA 与 LB 两条平行直线构成的无限二维平面 <strong>∞LALB</strong></li><li><strong>∞LALB</strong> 与颜色容器的平面交集即为渐变的范围</li></ul><h2 id="3-Exemple"><a href="#3-Exemple" class="headerlink" title="(3) Exemple"></a>(3) Exemple</h2><h3 id="1-矩形渐变"><a href="#1-矩形渐变" class="headerlink" title="1 矩形渐变"></a>1 矩形渐变</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="title function_">getElemntById</span>(<span class="string">&quot;myapp&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = doc.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_gradinet = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">my_gradinet.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">my_gradinet.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = my_gradinet;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><h3 id="2-线条渐变"><a href="#2-线条渐变" class="headerlink" title="2 线条渐变"></a>2 线条渐变</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="title function_">getElemntById</span>(<span class="string">&quot;myapp&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = doc.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_gradinet = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">my_gradinet.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">my_gradinet.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="property">lineWidth</span> = <span class="number">5</span>;</span><br><span class="line">ctx.<span class="property">strokeStyle</span> = my_gradient;</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">500</span>, <span class="number">400</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure><h1 id="圆形渐变"><a href="#圆形渐变" class="headerlink" title="圆形渐变"></a>圆形渐变</h1><h2 id="1-基本方法-1"><a href="#1-基本方法-1" class="headerlink" title="(1) 基本方法"></a>(1) 基本方法</h2><h3 id="createRadialGradient-x1-y1-r1-x2-y2-r2"><a href="#createRadialGradient-x1-y1-r1-x2-y2-r2" class="headerlink" title="createRadialGradient(x1, y1, r1, x2, y2, r2)"></a>createRadialGradient(x1, y1, r1, x2, y2, r2)</h3><ul><li>从开始圆 <strong>(x1, y1), r1</strong> 到 结束圆 <strong>(x2, y2), r1</strong></li><li>该坐标依然以整个页面为坐标系，而不是以填充渐变颜色的容器为基准</li></ul><h3 id="addColorStop-number-colorString-1"><a href="#addColorStop-number-colorString-1" class="headerlink" title="addColorStop(number, colorString)"></a>addColorStop(number, colorString)</h3><ul><li>规定颜色渐变-中间-结束的颜色变化</li><li>number 的值为 <strong>0 ~ 1</strong> 之间</li><li>colorString 为颜色值</li></ul><h2 id="2-渐变范围-1"><a href="#2-渐变范围-1" class="headerlink" title="(2) 渐变范围"></a>(2) 渐变范围</h2><h3 id="1-两圆为包含关系"><a href="#1-两圆为包含关系" class="headerlink" title="1 两圆为包含关系"></a>1 两圆为包含关系</h3><ul><li>当一个圆完全在另一个圆里时，渐变范围为两圆相交部分以外的圆环部分</li></ul><h3 id="2-两圆为部分相交或相离"><a href="#2-两圆为部分相交或相离" class="headerlink" title="2 两圆为部分相交或相离"></a>2 两圆为部分相交或相离</h3><ul><li>过两圆的两侧做相切线，要求每边的直线都要同时与两圆相切</li><li>两条相切直线：<ul><li>当两圆半径r相同时，构成一个无限长的平行二维面。其中从一个圆到另一个圆的部分为渐变范围</li><li>当两圆半径r不同时，两切线交于某一点。从该点起与两直线框定成无限长三角面。其中从一个圆到另一个圆的部分为渐变范围</li></ul></li></ul><h2 id="3-Example"><a href="#3-Example" class="headerlink" title="(3) Example"></a>(3) Example</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆形渐变</span></span><br><span class="line"><span class="keyword">let</span> circle_1 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">800</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">r</span>: <span class="number">50</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> circle_2 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">r</span>: <span class="number">80</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> my_gradients = draw2d.<span class="title function_">createRadialGradient</span>(circle_1.<span class="property">x</span>, circle_1.<span class="property">y</span>, circle_1.<span class="property">r</span>, circle_2.<span class="property">x</span>, circle_2.<span class="property">y</span>, circle_2.<span class="property">r</span>);</span><br><span class="line">my_gradients.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">my_gradients.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"></span><br><span class="line">draw2d.<span class="title function_">beginPath</span>();</span><br><span class="line">draw2d.<span class="property">fillStyle</span> = my_gradients;</span><br><span class="line">draw2d.<span class="title function_">fillRect</span>(<span class="number">600</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">draw2d.<span class="title function_">strokeRect</span>(<span class="number">600</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">draw2d.<span class="title function_">stroke</span>();</span><br><span class="line">draw2d.<span class="title function_">save</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw2d.arc(800, 100, )</span></span><br><span class="line">drawHelp.<span class="title function_">beginPath</span>();</span><br><span class="line">drawHelp.<span class="property">strokeStyle</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">drawHelp.<span class="title function_">arc</span>(circle_1.<span class="property">x</span>, circle_1.<span class="property">y</span>, circle_1.<span class="property">r</span>, <span class="number">0</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line">drawHelp.<span class="title function_">stroke</span>();</span><br><span class="line">drawHelp.<span class="title function_">beginPath</span>();</span><br><span class="line">drawHelp.<span class="title function_">arc</span>(circle_2.<span class="property">x</span>, circle_2.<span class="property">y</span>, circle_2.<span class="property">r</span>, <span class="number">0</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line">drawHelp.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性渐变&quot;&gt;&lt;a href=&quot;#线性渐变&quot; class=&quot;headerlink&quot; title=&quot;线性渐变&quot;&gt;&lt;/a&gt;线性渐变&lt;/h1&gt;&lt;h2 id=&quot;1-基本方法&quot;&gt;&lt;a href=&quot;#1-基本方法&quot; class=&quot;headerlink&quot; title=&quot;(1) 基</summary>
      
    
    
    
    <category term="Html" scheme="http://example.com/categories/Html/"/>
    
    
    <category term="canvas" scheme="http://example.com/tags/canvas/"/>
    
    <category term="绘图" scheme="http://example.com/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>大厂前端面经</title>
    <link href="http://example.com/2021/03/31/interview/bigFactory_1/"/>
    <id>http://example.com/2021/03/31/interview/bigFactory_1/</id>
    <published>2021-03-31T14:21:47.000Z</published>
    <updated>2022-03-26T01:50:30.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎阅读"><a href="#欢迎阅读" class="headerlink" title="欢迎阅读"></a>欢迎阅读</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>目前已经毕业，在去年2020秋招的摸爬滚打中，侥幸收获了几个小offer。最后也很幸运去腾讯实习了一段时间。所以想着把自己经历的大厂前端面试题整理出来，留给需要找实习工作的童鞋们一个参考。</p></blockquote><h2 id="大厂前端秋招面经"><a href="#大厂前端秋招面经" class="headerlink" title="大厂前端秋招面经"></a>大厂前端秋招面经</h2><blockquote><p>包括腾讯区域研发、字节跳动、腾讯日常实习、小米的前端面经</p></blockquote><span id="more"></span><h2 id="一-腾讯区域研发前端"><a href="#一-腾讯区域研发前端" class="headerlink" title="(一)腾讯区域研发前端"></a>(一)腾讯区域研发前端</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>* 自我介绍<br>* 介绍一下你最难的项目<br>* 谈谈对 vue 和 react 的理解，以及他们的区别<br>* vue 常用指令说一下<br>* 父子组件传值？多个组件共享状态？有什么更好的处理方法？(vuex或者其他状态管理解决方案)<br>* vue-router 用过吗？说一下它常见的钩子函数<br>* vue路由的 hash 和 history 模式？<br>* vue 自定义指令<br>* vue 双向绑定原理<br>* vue 虚拟DOM 的 Diff 算法<br>* 浏览器事件循环机制<br>* node 事件循环机制呢？<br>* nextTick() 是什么任务？(宏任务or微任务？)<br>* 用 node.js 做过什么东西？<br>* websocket 怎么做的聊天服务器<br>* HTTP 和 WebSocket<br>* TCP 三次握手和四次挥手<br>* 常见的网络攻击？(说了 xss, xsrf, sql注入)<br>* 反问</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>结合自身学习介绍项目</li><li>我有说到发布 npm 包，封装组件，总结反思优化什么的，所以大部分问题都围绕我的介绍来问</li><li>npm 包开发测试到上传的流程</li><li>用 node 做了一个小的聊天服务器</li><li>如何看待 Vue 和 React 这些框架带来的好处？</li><li>模块开发的好处？</li><li>你觉得 element-ui 的哪些组件封装的较好？</li><li>如果让你封装自己的组件应该怎么做？</li><li>面对新的框架和技术你怎么学习？</li><li>你怎么规划未来的前端学习？</li></ul><h3 id="三面HR面"><a href="#三面HR面" class="headerlink" title="三面HR面"></a>三面HR面</h3><ul><li>自我介绍</li><li>为什么打算来这？</li><li>你的期望薪资？</li><li>你在学校做了哪些对自己有意义的事？</li><li>面试官让等待后续，通过的话会打电话或发邮件通知接下来的进展</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>总结下来感觉问题都是交叉的，基础、框架、网络安全、项目都有。二面的时候让自我介绍加项<br>目介绍，后面问题都是围绕你的回答展开。HR面正常回答就好，表现出你想去公司工作的愿望</p></blockquote><h2 id="二-字节跳动前端"><a href="#二-字节跳动前端" class="headerlink" title="(二)字节跳动前端"></a>(二)字节跳动前端</h2><h3 id="一面-1h"><a href="#一面-1h" class="headerlink" title="一面(1h)"></a>一面(1h)</h3><p>* 自我介绍</p><p>* Flex布局，实现两个子元素垂直，并且一个靠右一个靠左</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>css代码</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">   <span class="attribute">align-items</span>: center;</span><br><span class="line">   <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> green solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>* JS基本数据类型<br>* 闭包<br>* 你说到了作用域链，那么你来谈一下作用域？<br>* 说到了执行上下文，所以又问了执行上下文<br>* 继续深入问到变量提升、词法作用域、动态作用域</p><ul><li>看一点相关的题目吧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="comment">//ƒ foo()&#123;</span></span><br><span class="line"><span class="comment">//    console.log(&quot;foo&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&#x27;bob&#x27;</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="comment">//tom</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()(); </span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="comment">//window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">bar</span>(); </span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="comment">//&#123;bar: f&#125;</span></span><br></pre></td></tr></table></figure><p>* http的请求方法<br>* http常见状态码</p><ul><li>TCP 和 UDP区别<br>* 为什么浏览器的请求有两次，一次options，第二次才是真正请求？哪些场景用到<br>* 模拟一个队列<br>* 数组扁平化？至少两种方法实现<br>* 反问</li></ul><h3 id="二面-1h"><a href="#二面-1h" class="headerlink" title="二面(1h)"></a>二面(1h)</h3><p>* 问了项目中的D3.js</p><ul><li>前端展示统计图或者一些复杂的图片是用图片好还是svg生成，这两种方式的优缺点，以及如何做取舍</li><li>最近出了 Vue 3.0,有了解过它与 Vue 2.0 的区别吗？</li><li>Vue 3.0 的 Composition API 有了解吗？<br>* Css画圆有哪些方式？<br>* 如何知道某个dom元素是否在当前可视窗口呢？<br>* scrollTop如何获取？<br>* Css的position的常见属性，sticky用过吗？<br>* Promise说一下<br>* Promise.all用过吗，自己用promise封装一个Promise.all？要求每一个promise能并行执行，并且要保证最后的回调参数顺序与执行顺序一致（解释：每个 promise 封装的请求不一定会按照调用顺序得到响应，可能后面调用的比前面的要快，但一样要保证最后的顺序是按照调用顺序的）<br>* 写一个题吧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: &#123;b : &#123;c : &#123;<span class="attr">d</span>: <span class="number">3</span>&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">obj, str, defaultValue</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getValue</span>(obj, <span class="string">&#x27;a.b.c.d&#x27;</span>, <span class="number">1</span>) =&gt; <span class="number">3</span> (存在该属性返回该属性对应的值)</span><br><span class="line"></span><br><span class="line"><span class="title function_">getValue</span>(obj, <span class="string">&#x27;a.b.c.d.e&#x27;</span>, <span class="number">1</span>) =&gt; <span class="number">1</span> (出现错误返回传入的默认值)</span><br><span class="line"></span><br><span class="line">改动，能处理数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj_1 = &#123;<span class="attr">a</span>: &#123;b : &#123;c : &#123;<span class="attr">d</span>: [&#123;e : <span class="number">4</span>&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getValue</span>(obj_1, <span class="string">&#x27;a.b.c.d[0].e&#x27;</span>, <span class="number">1</span>) =&gt; <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>改动前的代码实现（不一定对，望大家给个建议）</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRightValue</span>(<span class="params">obj, propertyString, defaultValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = propertyString.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(str[i])) &#123;</span><br><span class="line">          obj = obj[str[i]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> defaultValue;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span> &#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getRightValue</span>(obj, <span class="string">&#x27;a.b.c.d&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li><strong>改动后加上了数组，所以细节要处理好，我当时卡壳了没弄出来</strong></li></ul><p>* 反问</p><h3 id="三面-35min"><a href="#三面-35min" class="headerlink" title="三面(35min)"></a>三面(35min)</h3><ul><li>前两次的面试感觉怎么样？</li><li>通过之前的面试觉得自己还有哪些问题？</li><li>说一下你认为做得好的一个项目，遇到了些什么问题？</li><li>说了一个项目，然后接下来大部分时间都是围绕这个项目交流</li><li>问了自己更偏向于实习还是正式，然后自己回答：优先考虑正式 offer，如果达不到正式批要求，给一个实习 offer 也可以？？哈哈哈我太天真了，，，</li><li>反问了具体的业务，还有自己有待提高的地方</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>因为自己没有实习经历，项目都是自己写的，一下子想不出什么难点，只是简单聊了一些功能实现。所以建议大家以后聊项目时，有好的实习经历，就说一下实习的项目，没有实习只有自己项目的，也要往自己项目里面添加一些亮点（难点）。面试之前也要梳理好自己的项目，不然面试一下想不起来细节就尴尬了，别像我一样，，，呜，，，</p></blockquote><h2 id="三-腾讯日常实习"><a href="#三-腾讯日常实习" class="headerlink" title="(三)腾讯日常实习"></a>(三)腾讯日常实习</h2><h3 id="一面-43min"><a href="#一面-43min" class="headerlink" title="一面(43min)"></a>一面(43min)</h3><ul><li>介绍一下自己的项目</li><li>http 状态码</li><li>TCP 和 UDP</li><li>get 和 post 区别？</li><li>浏览器如何渲染</li><li>进程和线程的区别</li><li>场景题，5种颜色的球，每种颜色球有无数个，每人每次拿两个球，问至少多少人拿，才能保证至少有两个人拿的球一模一样。</li><li>编程题：找出一组数中两两相加为零的所有组合</li><li>说一说快排</li><li>后端能写些什么</li></ul><h3 id="二面-15min"><a href="#二面-15min" class="headerlink" title="二面(15min)"></a>二面(15min)</h3><ul><li>项目中的难点</li><li>聊了一个项目中的部分功能实现</li><li>有合作开发的团队项目吗</li><li>如何调试数据的</li><li>高数学过吗？？？</li><li>线性代数学过吗？说一说用矩阵的知识解方程</li><li>概率论在it中的应用</li><li>什么时候能来实习？实习多久?</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote><p>这个日常实习很迷，而且一开始面试就明确说了实习后面不会留。考察比较偏算法和逻辑思维</p></blockquote><h2 id="四-小米前端"><a href="#四-小米前端" class="headerlink" title="(四)小米前端"></a>(四)小米前端</h2><h3 id="一面-30min"><a href="#一面-30min" class="headerlink" title="一面(30min)"></a>一面(30min)</h3><ul><li>自我介绍</li><li>统计字符串字符出现个数</li><li>原型链说一下</li><li>原型继承写一下</li><li>vue怎么通信的</li><li>用类写一个发布订阅者模式</li><li>Css 垂直居中</li><li>vue组件的 data 为什么是一个函数</li><li>http 与 https 区别</li><li>http 304 ?</li><li>说一说你的优势</li><li>说一说自己未来三年规划</li><li>反问</li></ul><h3 id="二面-20min"><a href="#二面-20min" class="headerlink" title="二面(20min)"></a>二面(20min)</h3><ul><li>学习方式？</li><li>项目中的难点</li><li>统计页面标签个数？</li><li>聊了一些经历，对事情的看法</li><li>给面试官看了自己的学习笔记</li><li>自己的优缺点</li><li>反问，</li><li>因为没有实习经历，问了公司项目的大体开发流程。面试官小哥哥很有耐心的概括了一遍。非常感谢！</li><li>问了自己不足的地方</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><blockquote><p>小米前端的面试整体上来说是比较偏基础的，面试官人也很好。算法题需要掌握一些基础的</p></blockquote><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><blockquote><p>希望这些大厂面经能对你有所帮助，虽说是2020年的秋招，但是万变不离其宗，我想2021年秋招考察的依然是这些 –&gt; 扎实基础 + 基本必须掌握的算法 + 知识的广度与深度。</p></blockquote><blockquote><p>学弟学妹以及万千互联网求职者们，加油！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;欢迎阅读&quot;&gt;&lt;a href=&quot;#欢迎阅读&quot; class=&quot;headerlink&quot; title=&quot;欢迎阅读&quot;&gt;&lt;/a&gt;欢迎阅读&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;目前已经毕业，在去年2020秋招的摸爬滚打中，侥幸收获了几个小offer。最后也很幸运去腾讯实习了一段时间。所以想着把自己经历的大厂前端面试题整理出来，留给需要找实习工作的童鞋们一个参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;大厂前端秋招面经&quot;&gt;&lt;a href=&quot;#大厂前端秋招面经&quot; class=&quot;headerlink&quot; title=&quot;大厂前端秋招面经&quot;&gt;&lt;/a&gt;大厂前端秋招面经&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;包括腾讯区域研发、字节跳动、腾讯日常实习、小米的前端面经&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="前端面经" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="JS 面经" scheme="http://example.com/tags/JS-%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="大厂面经" scheme="http://example.com/tags/%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>httpBasic</title>
    <link href="http://example.com/2020/10/30/computerNetwork/httpBasic/"/>
    <id>http://example.com/2020/10/30/computerNetwork/httpBasic/</id>
    <published>2020-10-30T12:53:01.000Z</published>
    <updated>2020-10-30T13:09:02.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="请求报文的构成"><a href="#请求报文的构成" class="headerlink" title="请求报文的构成"></a>请求报文的构成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="variable constant_">GET</span>/<span class="variable constant_">POST</span>..) (<span class="regexp">/index) HTTP/</span><span class="number">1.1</span>  </span><br><span class="line"> 协议       资源地址  http版本  </span><br><span class="line">(<span class="attr">HOST</span>: tzwlink.<span class="property">xyz</span>)  </span><br><span class="line"> 域名  </span><br><span class="line">  </span><br><span class="line">(userName=gre&amp;age=<span class="number">21</span>)  </span><br><span class="line"> 请求内容  </span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p>例如  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /blogart <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>  </span><br><span class="line"><span class="attr">HOST</span>: tzwlink.<span class="property">xyz</span>  </span><br><span class="line"><span class="title class_">Connection</span>: keep-alive  </span><br><span class="line">  </span><br><span class="line">name=great&amp;age=<span class="number">21</span>  </span><br></pre></td></tr></table></figure><h2 id="响应报文的构成"><a href="#响应报文的构成" class="headerlink" title="响应报文的构成"></a>响应报文的构成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="variable constant_">HTTP</span>/<span class="number">1.1</span>) (<span class="number">200</span>) (<span class="variable constant_">OK</span>)  </span><br><span class="line"> http版本  状态码 状态码解释原因  </span><br><span class="line">(<span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">10</span> <span class="title class_">Jul</span> <span class="number">2020</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">34</span> <span class="variable constant_">GMT</span>)  </span><br><span class="line"> 创建响应的时间  </span><br><span class="line">(<span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">600</span>)  </span><br><span class="line"> 字节大小  </span><br><span class="line">(<span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html)  </span><br><span class="line">  </span><br><span class="line">(<span class="language-xml">&lt;html\&gt;...)  </span></span><br><span class="line"><span class="language-xml"> 响应内容  </span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">例如  </span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">HTTP/1.1 200 OK  </span></span><br><span class="line"><span class="language-xml">Date: Tue, 10 Jul 2020 15:37:34 GMT  </span></span><br><span class="line"><span class="language-xml">Content-Length: 600  </span></span><br><span class="line"><span class="language-xml">Content-Type: text/html</span></span><br><span class="line"><span class="language-xml">&lt;html\&gt;....&lt;/html\&gt;  </span></span><br></pre></td></tr></table></figure><h2 id="HTTP的请求响应方法"><a href="#HTTP的请求响应方法" class="headerlink" title="HTTP的请求响应方法"></a>HTTP的请求响应方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><blockquote><p>指定服务器并发送请求，一般返回文本内容</p></blockquote><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><blockquote><p>向服务器发送数据，服务器返回处理结果</p></blockquote><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><blockquote><p>上传文本内容，类似 FTP 协议上传文件，但是不太安全，一般不使用</p></blockquote><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><blockquote><p>用来获取服务器的头部相关信息、资源更新时间等，服务器只返回头部信息，不返回主体内容</p></blockquote><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>用来请求服务器删除某项资源</p></blockquote><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><p>用来查询服务器支持哪些方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> \* <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>  </span><br><span class="line"><span class="attr">HOST</span>: tzwlink.<span class="property">xyz</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//响应  </span></span><br><span class="line">  </span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span>  </span><br><span class="line"><span class="title class_">Allow</span>: <span class="variable constant_">GET</span>,<span class="variable constant_">POST</span>,<span class="variable constant_">PUT</span>,<span class="variable constant_">HEAD</span>  </span><br></pre></td></tr></table></figure><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><blockquote><p>使用隧道连接，比如 SSL 安全套层</p></blockquote><h2 id="持久连接和Cookie"><a href="#持久连接和Cookie" class="headerlink" title="持久连接和Cookie"></a>持久连接和Cookie</h2><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p>原本的 http 中，一旦传输完成报文主体，那么 tcp 就断了，但是如果 html 文档里还有图片、数据也需要请求时，还要在建立 tcp 连接再次请求。这样的话太浪费，我们完全可以让 tcp 继续连接，把文档中需要请求的地方请求完，然后如果一段时间都没请求时在断开。</p></blockquote><blockquote><p>所以引入了 Content: keep-alive，要求就是只要任何一方不提出断开，那么就一直连接</p></blockquote><h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><blockquote><p>以往，请求需要得到回应后才能继续下一条请求，这样其实一点也不高效。因为服务器端是可以同时处理大量请求的。</p></blockquote><blockquote><p>管线化技术实现了可以同时发送多个请求，然后依次响应，无需等待每一次的响应结束。这样一来 web 页面效率大大提高</p></blockquote><h2 id="使用-Cookie-进行状态管理"><a href="#使用-Cookie-进行状态管理" class="headerlink" title="使用 Cookie 进行状态管理"></a>使用 Cookie 进行状态管理</h2><blockquote><p>以往的 http 传输完成后并不会保存信息，通过 Cookie 会在初次请求之后保存部分信息（比如用户登录信息），然后再次请求时可以将 Cookie 加入请求报文中</p></blockquote><h2 id="报文信息"><a href="#报文信息" class="headerlink" title="报文信息"></a>报文信息</h2><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><blockquote><p>前面大概讲过</p></blockquote><p><img src="http://101.37.83.157:3000/github/art/http/http1-1.jpg" alt="格式"></p><blockquote><p>例子</p></blockquote><p><img src="http://101.37.83.157:3000/github/art/http/http1-2.jpg" alt="请求与响应"></p><h2 id="编码传输"><a href="#编码传输" class="headerlink" title="编码传输"></a>编码传输</h2><blockquote><p>某些时候文件内容较多可以采用编码压缩的方式，但是解压时会增大服务器负担</p></blockquote><ul><li>gzip</li><li>compress</li></ul><h2 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h2><blockquote><p>当文件较大时，可以分割为多个部分分时传送，让浏览器一块一块的显示页面</p></blockquote><h2 id="获取部分内容-“获取部分内容”-获取部分内容"><a href="#获取部分内容-“获取部分内容”-获取部分内容" class="headerlink" title="获取部分内容 “获取部分内容”)获取部分内容"></a>获取部分内容 “获取部分内容”)获取部分内容</h2><blockquote><p>当某个内容下载到一半失败时，重新下载往往从头开始，所以引入可以指定范围，比如重新加载时可以从后面一半开始。返回成功状态码 206</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /great.<span class="property">png</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>  </span><br><span class="line"><span class="attr">HOST</span>: www.<span class="property">tzwlink</span>.<span class="property">xyz</span>  </span><br><span class="line"><span class="title class_">Range</span>: bytes = <span class="number">5000</span>\-<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//响应  </span></span><br><span class="line">  </span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span>  </span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">10</span> <span class="title class_">Jul</span> <span class="number">2020</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">34</span> <span class="variable constant_">GMT</span>  </span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Range</span>: bytes <span class="number">5000</span>\-<span class="number">10000</span>/<span class="number">10000</span>  </span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">5000</span>  </span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: image/jpeg</span><br></pre></td></tr></table></figure><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><ul><li><strong>200</strong> 表示成功处理请求，并且返回了响应报文内容</li><li><strong>204</strong> 表示成功处理请求，但是并没有什么资源可以返回，利用这个可以做一些数据修改，添加数据的请求</li><li><strong>206</strong> 表示成功处理部分内容的请求，返回请求所指定的报文内容</li></ul><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><ul><li><strong>301</strong> 永久重定向，将请求的 URI 资源永久重定向到某个指定资源位置</li><li><strong>302</strong> 临时重定向，可能重定向的资源还会再次改变</li><li><strong>303</strong> 上面两种状态码明文上规定重定向时不允许改变请求方法，但是实际使用时大家都不怎么遵守，所以增加 303 表示允许重定向时修改请求方法</li><li><strong>304</strong> 允许在特定条件下从缓存获取资源，因为如果重复的请求都要依靠服务端查询那么工作量太大，所以可以从缓存中获取，无需再从数据库查询</li></ul><blockquote><p>比如某个页面初次打开返回 200 OK ，因为第一次需要的数据需要服务端查询数据库生成，这时客服端会在缓存文件中保存 Last Modified；在相同的第二次请求发生时，客服端会在请求中加入 If Modified Since，服务端收到后会根据更新时间判断是该重新查询？返回 200，还是就让客服端用之前的缓存？返回 304</p></blockquote><blockquote><p>动态页面一般不会保存这些信息，所以不主动添加的话那么每次请求都是 200，如果要做缓存加速就需要添加 Last Modified</p></blockquote><ul><li><strong>307</strong> 禁止 POST 变成 GET</li></ul><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><ul><li><strong>400</strong> 请求报文出现语法错误，服务端无法解析请求，但是浏览器会像对待 200 那样对待这个状态码</li><li><strong>401</strong> 请求认证，在请求资源之前需要认证，需要包含 Authorization 请求证书信息，一般像远程连接数据库就会有这个</li><li><strong>403</strong> 拒绝请求，服务端可以无理由拒绝对指定资源的请求</li><li><strong>404</strong> 服务端找不到指定资源</li></ul><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><ul><li><strong>500</strong> 服务端内部程序出现 bug，运行错误</li><li><strong>503</strong> 服务端关闭服务维护了，请求超时</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><blockquote><p>https-http-加密-认证-完整性保护 “https&#x3D;http+加密+认证+完整性保护”)https&#x3D;http+加密+认证+完整性保护</p></blockquote><blockquote><p>原始的http协议内容都是以明文发送，容易被盗取，并且通信时无法确认收到的信息是否完整，或者被篡改。也不知道通信双方是否真实；由此引入 https，事实上是在 http 上做了一些处理。</p></blockquote><blockquote><p>通过与 SSL 层合用，达到安全通信的效果。SSL 会先建立安全隧道才会通信的</p></blockquote><ul><li>确认通信双方身份 ： 通过证书认证*来确认双方身份的真实性</li><li>加密处理 ： 由发送方按照一定规则对 http 报文进行加密发送</li><li>完整性验证 ： 例如通过 MD5 和 SHA-1 散列值检验完整性</li></ul><blockquote><p>https 在 tcp 建立的基础上，还需要建立 SSL 连接，之后进行普通的经过加密的 http 请求</p></blockquote><blockquote><p>加密解密都需要秘钥，一般发送方使用对方提供的公共秘钥进行加密。接受方接受到了之后又使用自己的私有密钥进行解密</p></blockquote><h2 id="通信过程-“通信过程”-通信过程"><a href="#通信过程-“通信过程”-通信过程" class="headerlink" title="通信过程 “通信过程”)通信过程"></a>通信过程 “通信过程”)通信过程</h2><ol><li>客户端发送打招呼报文 client Hello给服务器，里面包含了 ssl 版本，加密组件等等信息，告诉服务端要干什么。</li><li>服务端收到了客户端打的招呼，就已 Server Hello 报文进行回复，告诉客服端服务器可以进行 ssl 通信。</li><li>紧接着服务端把自己的公开密钥证书发给客服端，客服端对发送的信息要依此进行加密，该报文叫做 Certificate 报文。</li><li>服务端还会在发一条报文 Server Hello Done，告诉客服端第一次握手（协商）结束，确认了需要用的密钥。</li><li>之后客服端作为回应发送 Client Key Exchange 报文，并且还发送了名为 Pre-master secret 的随机密码串。当然这条信息已经经过第三步的加密处理。</li><li>客户端又继续发送 Change Cipher Spec 报文，告诉服务端从这里开始以后我发送报文就要按照刚刚的 Pre-master secret 随机密码串进行加密。当然这之前还是按照第三步服务端给的密钥加密。</li><li>客服端最后发送 Finshed 报文表示结束。</li><li>服务端必须正确解析上一步客服端发送的 Finshed 报文，因为里面包含了从连接开始到这一步之前所有报文的整体校验值，如果服务端成功解析说明密钥交换成功，服务端就会发送 Change Cipher Spec 报文</li><li>最后服务端也发送 Finshed 报文表示整个 ssl 连接成功可以进行 http 加密通信了</li></ol><ul><li>断开连接时客服端会发送 close_notify 报文表示断开。在这后 tcp 连接也断开。</li></ul><blockquote><p><strong>图片来自图解HTTP</strong></p></blockquote><p><img src="http://101.37.83.157:3000/github/art/http/https1-1.jpg" alt="http通信示意图"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h2 id=&quot;请求报文的构成&quot;&gt;&lt;a href=&quot;#请求报文的构成&quot; class=&quot;headerlink&quot; title=&quot;请求报文的构成&quot;&gt;&lt;/a&gt;请求报文的构成&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;variable constant_&quot;&gt;GET&lt;/span&gt;/&lt;span class=&quot;variable constant_&quot;&gt;POST&lt;/span&gt;..) (&lt;span class=&quot;regexp&quot;&gt;/index) HTTP/&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 协议       资源地址  http版本  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;attr&quot;&gt;HOST&lt;/span&gt;: tzwlink.&lt;span class=&quot;property&quot;&gt;xyz&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 域名  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(userName=gre&amp;amp;age=&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 请求内容  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="HTTPS" scheme="http://example.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>cssMustKnow</title>
    <link href="http://example.com/2020/10/30/css/cssMustKnow/"/>
    <id>http://example.com/2020/10/30/css/cssMustKnow/</id>
    <published>2020-10-30T12:42:07.000Z</published>
    <updated>2020-10-30T13:08:31.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="必会的几个css基础知识"><a href="#必会的几个css基础知识" class="headerlink" title="必会的几个css基础知识"></a>必会的几个css基础知识</h1><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS-选择器"></a>CSS-选择器</h2><blockquote><p>这一块可以说是很基础了，只有用选择器选中元素，才能使样式生效</p></blockquote><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><blockquote><p>直接选中原生 html 标签名，该选择器可以说是优先级最低的了，在没有其它类型选择器时才会考虑它</p></blockquote><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><blockquote><p>选中标签定义的 id 名字，该选择器高于类选择器但是低于内联样式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#great</span> &#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><blockquote><p>选中标签中定义的 class 名字，该选择器优先级高于标签选择低于 id 选择</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.great-class</span> &#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="子元素选择"><a href="#子元素选择" class="headerlink" title="子元素选择"></a>子元素选择</h3><blockquote><p>基于上面的方式衍生的，目的是为了区别不同父标签下相同 标签名，id 名，类名的元素。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#great</span> <span class="selector-tag">div</span>&#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.great-class</span> <span class="selector-tag">aside</span> <span class="selector-tag">span</span>&#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="selector-class">.great-class</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span>&#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="群组选择器"><a href="#群组选择器" class="headerlink" title="群组选择器"></a>群组选择器</h3><blockquote><p>同时选中多个元素，用逗号隔开</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#great</span>, <span class="selector-class">.great-class</span>, <span class="selector-tag">div</span>&#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="相邻选择器"><a href="#相邻选择器" class="headerlink" title="相邻选择器"></a>相邻选择器</h3><blockquote><p>选中相邻的兄弟元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#one</span> + <span class="selector-tag">section</span>&#123;  </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;  </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">50px</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><blockquote><p>选中指定属性值的所有元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;one&quot;</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[title=<span class="string">&quot;one&quot;</span>]</span> &#123;  </span><br><span class="line"> <span class="attribute">color</span>: red;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class=<span class="string">&quot;two&quot;</span>]</span> &#123;  </span><br><span class="line"> <span class="attribute">color</span>: blue;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="伪类元素"><a href="#伪类元素" class="headerlink" title="伪类元素"></a>伪类元素</h3><blockquote><p>可以根据元素的状态来进行样式的改变</p></blockquote><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><ul><li>:first-line 匹配元素的第一行</li><li>:first-letter 匹配元素的第一个字母</li><li>:before 在元素之前插入生成的内容</li><li>:after 在元素之后插入生成的内容</li></ul><h4 id="常见伪类"><a href="#常见伪类" class="headerlink" title="常见伪类"></a>常见伪类</h4><ul><li>:first-child 父元素下第一个孩子</li><li>:link 未被点击的链接</li><li>:visited 已被点击的链接</li><li>:active 鼠标按在上面但是没有释放</li><li>:hover 鼠标悬停</li><li>:focus 获得鼠标焦点</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child &#123;  </span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">17px</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;  </span><br><span class="line"> <span class="attribute">color</span>: green;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h3><ul><li>:nth-child(n) 父元素下第 n 个子元素</li></ul><h3 id="选择器优先级算法"><a href="#选择器优先级算法" class="headerlink" title="选择器优先级算法"></a>选择器优先级算法</h3><blockquote><p>众多类型的选择器方式，还可以组合使用，那么如何区分呢</p></blockquote><blockquote><p>优先级由 A，B，C，D 四个值确定，计算规则如下</p></blockquote><ul><li>存在内联样式，A &#x3D; 1，否则 A &#x3D; 0</li><li>B 的值等于 ID选择器 出现的次数;</li><li>C 的值等于 类选择器 + 属性选择器 + 伪类 出现的总次数;</li><li>D 的值等于 标签选择器 + 伪元素 出现的总次数</li></ul><blockquote><p>将四个值当成一个序列，(A，B，C，D)，按照从左往右的顺序依次比较，较大者直接胜出，相等继续比较下一位，如四个值都相等，后面的样式覆盖前面的</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>\=<span class="string">&quot;one&quot;</span> <span class="attr">class</span>\=<span class="string">&quot;two&quot;</span>\&gt;</span>  </span><br><span class="line"> &lt;p\&gt;&lt;/p\&gt;  </span><br><span class="line">&lt;/div\&gt; </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#one</span> <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;  </span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">17px</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.two</span> <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;  </span><br><span class="line"> <span class="attribute">color</span>: green;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>第一个样式 (0, 1, 1, 1)</li><li>第二个样式 (0, 0, 1, 1)</li></ul><blockquote><p>比较到第二位也就是 B 时，1 &gt; 0，所以第一个样式优先</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;必会的几个css基础知识&quot;&gt;&lt;a href=&quot;#必会的几个css基础知识&quot; class=&quot;headerlink&quot; title=&quot;必会的几个css基础知识&quot;&gt;&lt;/a&gt;必会的几个css基础知识&lt;/h1&gt;&lt;h2 id=&quot;CSS-选择器&quot;&gt;&lt;a href=&quot;#CSS-选择器&quot; class=&quot;headerlink&quot; title=&quot;CSS-选择器&quot;&gt;&lt;/a&gt;CSS-选择器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这一块可以说是很基础了，只有用选择器选中元素，才能使样式生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;元素选择器&quot;&gt;&lt;a href=&quot;#元素选择器&quot; class=&quot;headerlink&quot; title=&quot;元素选择器&quot;&gt;&lt;/a&gt;元素选择器&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;直接选中原生 html 标签名，该选择器可以说是优先级最低的了，在没有其它类型选择器时才会考虑它&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="选择器" scheme="http://example.com/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
    <category term="CSS优先级算法" scheme="http://example.com/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>es6basic</title>
    <link href="http://example.com/2020/10/30/es6/es6basic/"/>
    <id>http://example.com/2020/10/30/es6/es6basic/</id>
    <published>2020-10-30T12:21:16.000Z</published>
    <updated>2020-10-30T13:09:34.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-新增声明方式与各种扩展"><a href="#ES6-新增声明方式与各种扩展" class="headerlink" title="ES6 新增声明方式与各种扩展"></a>ES6 新增声明方式与各种扩展</h1><blockquote><p>为了提高开发效率，语言设计者从原生上支持了许多快捷高效的新操作。故推出称为新一代标准 ES6</p></blockquote><span id="more"></span><h1 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><blockquote><p>let 声明的变量只在当前块有效，适用于 for 循环、if 条件句等等</p></blockquote><ul><li><p><strong>另外，es6 规定块级作用域必须要有大括号，否则就认为没有块级作用域</strong></p></li><li><p>在 for 循环中，定义循环变量的地方可以为父作用域，而循环体又可以为子作用域</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;  </span><br><span class="line"> <span class="keyword">let</span> i = <span class="string">&quot;Great&quot;</span>;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Great  </span></span><br><span class="line"><span class="comment">// Great  </span></span><br><span class="line"><span class="comment">// Great  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line"><span class="comment">//Uncaught ReferenceError: i is not defined  </span></span><br></pre></td></tr></table></figure><h3 id="没有变量提升"><a href="#没有变量提升" class="headerlink" title="没有变量提升"></a>没有变量提升</h3><ul><li><p>用 var 来定义变量时，有时存在提升，即可以在声明之前调用不报错但会返回 undefined ；但是 let 不行，必须在声明之后使用，否则就会报错</p></li><li><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错</p></li><li><p>另一方面，若是由 var 声明的变量又被 let 重新声明，那么在这次重新声明之前调用也会报错，这被称为暂时性死区，typeof 使用在声明之前也会报错</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//undefined  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//Uncaught ReferenceError: b is not defined  </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;  </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">7</span>;  </span><br><span class="line"><span class="comment">//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*  </span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//3  </span></span><br><span class="line">c = <span class="number">5</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c);<span class="comment">//number  </span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line"> c = <span class="number">0</span>; <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;c&#x27; before initialization  </span></span><br><span class="line"> <span class="keyword">let</span> c = <span class="number">4</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><blockquote><p>在同一作用域里，不允许重复声明一个变量</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;<span class="comment">// dentifier &#x27;a&#x27; has already been declared  </span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line"> <span class="keyword">let</span> a = <span class="number">5</span>;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 5  </span></span><br><span class="line"> <span class="keyword">let</span> c = <span class="number">4</span>;  </span><br><span class="line"> <span class="keyword">let</span> c = <span class="number">7</span>;<span class="comment">// dentifier &#x27;c&#x27; has already been declared  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">G</span>(<span class="params">arg</span>) &#123;  </span><br><span class="line"> <span class="keyword">let</span> arg = <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title function_">G</span>(<span class="number">3</span>);<span class="comment">// Identifier &#x27;arg&#x27; has already been declared  </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>建议多使用 let 命令，因为它与 var 的作用几乎相同，但是 let 的规定更严格，也更符合先声明后使用的规则</strong></p></blockquote><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p>一经定义就要赋值，赋值后不能再次改变其值</p></li><li><p>与 let 一样，存在块级作用域，并且也要在声明之后使用，没有变量提升，存在死区现象</p></li><li><p>但是如果定义的是对象常量，则可以改变对象的属性，因为 const 此时存的是对象的指针，并不是其中所以属性的值</p></li></ul><h1 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h1><blockquote><p>用来获取当前宿主环境的全局作用域对象</p></blockquote><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组-变量-的解构赋值"><a href="#数组-变量-的解构赋值" class="headerlink" title="数组-变量-的解构赋值"></a>数组-变量-的解构赋值</h2><blockquote><p>传统的赋值很繁琐，利用解构赋值可以像 python 那样快速赋值；同时还允许使用默认值类似函数的参数默认值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始  </span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//解构赋值  </span></span><br><span class="line"><span class="keyword">let</span> \[a, b, c\] = \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>\];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);<span class="comment">//1 2 3  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//默认值  </span></span><br><span class="line"><span class="keyword">let</span> \[x, y = <span class="number">15</span>\] = \[<span class="number">13</span>\];  </span><br><span class="line"><span class="keyword">let</span> \[x1, y1 = <span class="number">15</span>\] = \[<span class="number">13</span>, <span class="number">17</span>\];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, x1, y1);<span class="comment">//13 15 13 17  </span></span><br></pre></td></tr></table></figure><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><blockquote><p>与数组解构类似，甚至可以嵌套赋值非常方便</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, age, getName, obj, <span class="attr">obj</span>: &#123;number&#125;&#125; = &#123;  </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Great&#x27;</span>,  </span><br><span class="line"> <span class="attr">age</span>: <span class="number">21</span>,  </span><br><span class="line"> <span class="title function_">getName</span>(<span class="params">s</span>) &#123; <span class="comment">//es6简写  </span></span><br><span class="line"> <span class="keyword">return</span> s;  </span><br><span class="line"> &#125;,  </span><br><span class="line"> <span class="attr">obj</span>: &#123;  </span><br><span class="line"> <span class="attr">number</span>: <span class="number">17</span>  </span><br><span class="line"> &#125;,  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, <span class="title function_">getName</span>(<span class="string">&#x27;tiga&#x27;</span>), obj, number);<span class="comment">//Great 21 tiga &#123;number: 17&#125; 17  </span></span><br></pre></td></tr></table></figure><h2 id="字符串解构赋值"><a href="#字符串解构赋值" class="headerlink" title="字符串解构赋值"></a>字符串解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> \[a,b,c,d,e\]  = <span class="string">&quot;Great&quot;</span>;  </span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">&quot;Tiga&quot;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d,e,len);<span class="comment">//G r e a t 4  </span></span><br></pre></td></tr></table></figure><h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><blockquote><p>使用反撇号 ` ，可当做普通字符串，也可以在其中嵌套任何 JS 表达式包括调用函数</p></blockquote><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(\<span class="string">`<span class="subst">$&#123;a \* <span class="number">10</span>&#125;</span> 减去 <span class="subst">$&#123;a \* <span class="number">5</span>&#125;</span> 等于 <span class="subst">$&#123;a \* <span class="number">10</span> - a \* <span class="number">5</span>&#125;</span>\`);//10 减去 5 等于 5  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">function Great(s) &#123;  </span></span><br><span class="line"><span class="string"> return s;  </span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">console.log(\`我叫<span class="subst">$&#123;Great(<span class="string">&#x27;Greatiga&#x27;</span>)&#125;</span>\`);//我叫Greatiga  </span></span><br></pre></td></tr></table></figure><h1 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><blockquote><p>允许在参数传递时设置参数默认值，当调用函数没用提供参数时就用默认参数，否则还是用提供的参数</p></blockquote><ul><li>设置参数默认值后，默认值会形成一个自己的作用域直到参数初始化完毕</li><li>比如 (x &#x3D; 1) 实际上执行的是 (let x &#x3D; 1)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name = <span class="string">&#x27;Great&#x27;</span>, age = <span class="number">21</span></span>) &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title class_">Person</span>();<span class="comment">// Great 21  </span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&#x27;Tiga&#x27;</span>, <span class="string">&#x27;3000&#x27;</span>);<span class="comment">// Tiga 3000  </span></span><br></pre></td></tr></table></figure><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><blockquote><p>其实就是对象展开符，形式 …变量，rest 参数后不能再有其他参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">k</span> = (<span class="params">...arg</span>) =&gt; arg.<span class="title function_">sort</span>();  </span><br><span class="line"><span class="title function_">k</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>);<span class="comment">// (6) \[0, 1, 2, 4, 7, 9\]  </span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p>简化了函数原来的写法</p></blockquote><ul><li>如果箭头函数不需要参数或者多个参数，可以使用圆括号包裹</li><li>如果函数体多于一条语句，那么可以用大括号包裹起来，但是需要用 return 语句返回</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(\[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>\].<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item \* <span class="number">10</span>));<span class="comment">// \[10, 20, 30\]  </span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; &#123;  </span><br><span class="line"> <span class="keyword">if</span>(x) &#123;  </span><br><span class="line"> <span class="keyword">return</span> y;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">else</span> &#123;  </span><br><span class="line"> <span class="keyword">return</span> x + y;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><ul><li><strong>箭头函数的 this 指向初始化它的时候的执行对象，并非是调用它的时候的执行对象；这一点与普通函数不同</strong></li><li>不能当成构造函数，使用 new 会报错</li><li>不能使用 arguments 对象，可以使用 rest 参数代替</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">21</span>;  </span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);  </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);  </span><br><span class="line"> &#125;,<span class="number">1000</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">sum.<span class="title function_">call</span>(&#123;x : <span class="number">3000</span>&#125;);  </span><br><span class="line"><span class="comment">//3000  </span></span><br><span class="line"><span class="comment">//1s 后  </span></span><br><span class="line"><span class="comment">//3000  </span></span><br></pre></td></tr></table></figure><h1 id="数组和对象的扩展"><a href="#数组和对象的扩展" class="headerlink" title="数组和对象的扩展"></a>数组和对象的扩展</h1><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><h3 id="数组扩展运算符"><a href="#数组扩展运算符" class="headerlink" title="数组扩展运算符"></a>数组扩展运算符</h3><blockquote><p>这个对于对象同样适用。同时只有函数调用时才能适用圆括号包裹，否则会报错</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...x);<span class="comment">//1 2 3 4 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> y = [...x];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`可以使用克隆<span class="subst">$&#123;y&#125;</span>`</span>);<span class="comment">//可以使用克隆1,2,3,4,5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> z = [<span class="number">0</span>, ...x, <span class="number">6</span>];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`可以简洁的合并数组<span class="subst">$&#123;z&#125;</span>`</span>);<span class="comment">//可以简洁的合并数组0,1,2,3,4,5,6  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = x;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(\<span class="string">`可以简洁的拆分数组\n a: <span class="subst">$&#123;a&#125;</span> \n b: <span class="subst">$&#123;b&#125;</span> \n c: <span class="subst">$&#123;c&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// a: 1   </span></span><br><span class="line"><span class="comment">// b: 2   </span></span><br><span class="line"><span class="comment">// c: 3,4,5  </span></span><br></pre></td></tr></table></figure><h3 id="Array-from-和-Array-of"><a href="#Array-from-和-Array-of" class="headerlink" title="Array.from() 和 Array.of()"></a>Array.from() 和 Array.of()</h3><ul><li>Array.from() 用于将类数组转换为真的数组</li><li>Array.of() 用于将一组值转换为数组</li></ul><h2 id="对象扩展-“对象扩展”-对象扩展"><a href="#对象扩展-“对象扩展”-对象扩展" class="headerlink" title="对象扩展 “对象扩展”)对象扩展"></a>对象扩展 “对象扩展”)对象扩展</h2><hr><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><blockquote><p>指向当前对象的原型对象，只能在对象的内部方法中使用</p></blockquote><h3 id="对象扩展运算符"><a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h3><blockquote><p>用法与数组类似</p></blockquote><h3 id="对象的复制拷贝"><a href="#对象的复制拷贝" class="headerlink" title="对象的复制拷贝"></a>对象的复制拷贝</h3><blockquote><p>使用 **Object.assign()**，但只是浅拷贝</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;x : <span class="number">13</span>&#125;;  </span><br><span class="line"><span class="keyword">let</span> b = &#123;y : <span class="number">17</span>&#125;;  </span><br><span class="line"><span class="keyword">let</span> c = &#123;z : <span class="number">19</span>&#125;;  </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(c, a, b);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//&#123;z: 19, x: 13, y: 17&#125; </span></span><br></pre></td></tr></table></figure><h3 id="新增对原型对象的操作"><a href="#新增对原型对象的操作" class="headerlink" title="新增对原型对象的操作"></a>新增对原型对象的操作</h3><blockquote><p>主要用来替代 __proto__</p></blockquote><ul><li>Object.setPrototypeOf(obj, prototype) 设置某一个对象的原型对象</li><li>Object.getPrototypeOf(obj) 获取某一个对象的原型对象</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ES6-新增声明方式与各种扩展&quot;&gt;&lt;a href=&quot;#ES6-新增声明方式与各种扩展&quot; class=&quot;headerlink&quot; title=&quot;ES6 新增声明方式与各种扩展&quot;&gt;&lt;/a&gt;ES6 新增声明方式与各种扩展&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为了提高开发效率，语言设计者从原生上支持了许多快捷高效的新操作。故推出称为新一代标准 ES6&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="ES6" scheme="http://example.com/categories/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>json</title>
    <link href="http://example.com/2020/09/22/javaScript/json/"/>
    <id>http://example.com/2020/09/22/javaScript/json/</id>
    <published>2020-09-22T05:16:02.000Z</published>
    <updated>2020-10-30T12:07:10.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote><p>JSON 是一种数据格式，并非是编程语言。不仅 JavaScript 可以使用，python、java等都支持；JSON可以说是前后端数据交互中一种重要的统一数据格式**</p></blockquote><ul><li>支持简单值</li><li>支持对象，嵌套对象</li><li>支持数组</li><li><strong>对象中的属性名必须要用双引号扩起来！！！</strong></li></ul><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Greatiga&quot;</span>,  </span><br><span class="line"> <span class="string">&quot;age&quot;</span>: <span class="number">21</span>,  </span><br><span class="line"> <span class="string">&quot;food&quot;</span>: &#123;  </span><br><span class="line"> <span class="string">&quot;favitor&quot;</span>: <span class="string">&quot;egg&quot;</span>,  </span><br><span class="line"> <span class="string">&quot;other&quot;</span>: <span class="string">&quot;beet&quot;</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="string">&quot;ary&quot;</span>: \[  </span><br><span class="line"> <span class="string">&quot;one&quot;</span>,  </span><br><span class="line"> <span class="string">&quot;two&quot;</span>: &#123;  </span><br><span class="line"> <span class="string">&quot;area&quot;</span>: <span class="string">&quot;China&quot;</span>  </span><br><span class="line"> &#125;,  </span><br><span class="line"> <span class="string">&quot;three&quot;</span>: <span class="string">&quot;Tiga&quot;</span>  </span><br><span class="line"> \]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h1><blockquote><p>可以将 JSON 解析为 JavaScript 对象。当然也可以反过来。</p></blockquote><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON-对象"></a>JSON-对象</h2><ul><li>stringify() 把 JS 对象序列化为 JSON 字符串</li><li>parse() 把 JSON 字符串解析为 JS 值</li></ul><h3 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h3><blockquote><p>stringify() 接受两个参数，参数1表示要序列化的 JS 对象。参数2为序列化的条件，参数3为序列化后值之间的间隔符</p></blockquote><h3 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h3><blockquote><p>通过传入数组或者函数作为第二个参数。那么方法就会返回筛选条件下的 JSON 字符串。<strong>生成的 JSON 字符串不包含多余的空格和换行</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = &#123;  </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Greatiga&quot;</span>,  </span><br><span class="line"> <span class="attr">age</span>: <span class="number">21</span>,  </span><br><span class="line"> <span class="attr">food</span>: &#123;  </span><br><span class="line"> <span class="attr">favitor</span>: <span class="string">&quot;egg&quot;</span>,  </span><br><span class="line"> <span class="attr">other</span>: <span class="string">&quot;beet&quot;</span>  </span><br><span class="line"> &#125;,  </span><br><span class="line"> <span class="attr">ary</span>: \[  </span><br><span class="line"> <span class="string">&quot;one&quot;</span>,  </span><br><span class="line"> <span class="string">&quot;three&quot;</span>  </span><br><span class="line"> \]  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json,\[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;food&quot;</span>\],<span class="string">&quot;--&quot;</span>));  </span><br><span class="line"><span class="comment">// &#123;  </span></span><br><span class="line"><span class="comment">// --&quot;name&quot;: &quot;Greatiga&quot;,  </span></span><br><span class="line"><span class="comment">// --&quot;age&quot;: 21,  </span></span><br><span class="line"><span class="comment">// --&quot;food&quot;: &#123;&#125;  </span></span><br><span class="line"><span class="comment">// &#125;  </span></span><br></pre></td></tr></table></figure><blockquote><p>传入函数时，如果函数筛选中返回 undefined ，那么对应的值就会被删除</p></blockquote><h2 id="解析-JSON"><a href="#解析-JSON" class="headerlink" title="解析-JSON"></a>解析-JSON</h2><blockquote><p>接受两个参数，参数 1 为要解析的字符串，参数 2 为解析条件函数</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;JSON 是一种数据格式，并非是编程语言。不仅 JavaScript 可以使用，python、java等都支持；JSON可以说是前后端数据交互中一种重要的统一数据格式**&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;支持简单值&lt;/li&gt;
&lt;li&gt;支持对象，嵌套对象&lt;/li&gt;
&lt;li&gt;支持数组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象中的属性名必须要用双引号扩起来！！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JSON" scheme="http://example.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="http://example.com/2020/09/22/javaScript/ajax/"/>
    <id>http://example.com/2020/09/22/javaScript/ajax/</id>
    <published>2020-09-22T05:13:32.000Z</published>
    <updated>2020-10-30T12:06:47.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ajax的核心是-XMLHttpReuest-对象，简称-XHR"><a href="#Ajax的核心是-XMLHttpReuest-对象，简称-XHR" class="headerlink" title="Ajax的核心是 XMLHttpReuest 对象，简称 XHR"></a>Ajax的核心是 XMLHttpReuest 对象，简称 XHR</h1><blockquote><p>由于 IE7 之前存在不同的 XHR 对象，所以如果要兼容所有浏览器，就必须做预处理。对于其他浏览器，任何版本都支持相同的 XHR 对象。仅仅 IE7 之前有差异。</p></blockquote><span id="more"></span><ul><li>IE7 之前存在 MSXML2.XMLHttp.6.0–MSXML2.XMLHttp.3.0–MSXML2.XMLHttp 这三个版本</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><blockquote><p>在其他浏览器包括 IE7+ 中，直接使用 <strong>new XMLHttpRequest()</strong> 即可创建原生 XHR 对象。但是如果要做 IE7- 的兼容就必须预处理，因为 IE- 中并没有 XMLHttpRequest 这个构造函数，只有 <strong>ActiveXObject</strong> 这个构造函数并且该构造函数需指定版本</p></blockquote><ul><li>下面的函数适用于所有浏览器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createXHR</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">XMLHttpRequest</span> != <span class="string">&quot;undefined&quot;</span>) &#123; <span class="comment">//若不是 IE7 之前的版本直接返回通用构造函数  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">ActiveXObject</span> != <span class="string">&quot;undefined&quot;</span>) &#123; <span class="comment">//若是 IE7 之前的版本则需要逐个尝试找到对应的版本  </span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">activeXString</span> != <span class="string">&quot;string&quot;</span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> version = \[<span class="string">&quot;MSXML2.XMLHttp.6.0&quot;</span>, <span class="string">&quot;MSXML2.XMLHttp.3.0&quot;</span>, <span class="string">&quot;MSXML2.XMLHttp&quot;</span>\];  </span><br><span class="line">    version.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(item);  </span><br><span class="line">        <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">activeXString</span> = item;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法创建 XHR 对象&quot;</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">activeXString</span>);  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;该浏览器或宿主环境不支持 XHR 对象&quot;</span>); <span class="comment">// 若是 IE7 的三个 XHR 版本都没有那说明运行环境不支持 XHR 对象  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">createXHR</span>());  </span><br><span class="line"><span class="comment">// XMLHttpRequest &#123;onreadystatechange: null, readyState: 0, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …&#125;  </span></span><br></pre></td></tr></table></figure><h1 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h1><ul><li>status 响应码，例如 200、404、500等</li><li>readyState 请求阶段过程<ul><li>0 未初始化，连 open() 都没调用</li><li>1 开始，已经调用 open() ，尚未调用 send()</li><li>2 发送，调用 send() ，但未收到响应</li><li>3 接受，收到部分数据</li><li>4 完成，收到所有数据，可以直接使用</li></ul></li><li>statusText 响应码对应的提示文本</li><li>responseText 收到的内容主体，例如 html、css、js、图片等等</li><li>responseXML 如果收到的是 xml 才会有内容，否则就为空</li><li>getRequestHeader() 获取部分响应报文头部信息</li><li>getAllRequestHeaders() 获取所有响应报文头部信息</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Ajax的核心是-XMLHttpReuest-对象，简称-XHR&quot;&gt;&lt;a href=&quot;#Ajax的核心是-XMLHttpReuest-对象，简称-XHR&quot; class=&quot;headerlink&quot; title=&quot;Ajax的核心是 XMLHttpReuest 对象，简称 XHR&quot;&gt;&lt;/a&gt;Ajax的核心是 XMLHttpReuest 对象，简称 XHR&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;由于 IE7 之前存在不同的 XHR 对象，所以如果要兼容所有浏览器，就必须做预处理。对于其他浏览器，任何版本都支持相同的 XHR 对象。仅仅 IE7 之前有差异。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="Ajax" scheme="http://example.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>es6 新增函数及异步函数</title>
    <link href="http://example.com/2020/09/11/es6/function/"/>
    <id>http://example.com/2020/09/11/es6/function/</id>
    <published>2020-09-11T14:12:28.000Z</published>
    <updated>2020-10-30T12:09:00.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>直接执行函数没有效果，必须通过 next() 来移动函数内部的指针，让它指向接下来一个 yield 表达式</p></blockquote><span id="more"></span><blockquote><p>有一个前提那就是，yield 必须在 Generator 函数中使用，否则会报错</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title class_">Great</span>() &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;am&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Great&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;And you?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="title class_">Great</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;直接执行函数没有效果，必须通过 next() 来移动函数内部的指针，让它指向接下来一个 yield 表达式&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>dom 事件机制</title>
    <link href="http://example.com/2020/09/06/browser/domEvent/"/>
    <id>http://example.com/2020/09/06/browser/domEvent/</id>
    <published>2020-09-06T09:19:06.000Z</published>
    <updated>2020-09-09T02:44:41.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><blockquote><p>这一概念源自于对事件触发对象的思考。例如常见的点击事件，鼠标移动事件。这些事件发生之时，往往不只是点击或者移动到某一特定元素上。</p></blockquote><blockquote><p>比如点击某一个按钮，而它是由上一层的父标签，或许在上一层还有父标签甚至是整个页面。因此点击一个元素可以看成是同时点击了父标签或者整个页面。那么此时事件应该怎么响应到指定标签呢？</p></blockquote><span id="more"></span><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><blockquote><p>即事件从指定元素开始传播到最外层的元素，并且该事件不仅会在指定元素上发生，还会在传播过过程中的每一个元素上发生。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>事件冒泡: button -&gt; div -&gt; body -&gt; html -&gt; document</li></ul><blockquote><p>如上，再点击click之后，事件从 button 开始传播至 html ，再到 documet。这一个过程也称为事件冒泡</p></blockquote><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><blockquote><p>与事件冒泡刚好相反，事件从最外层的 documet 开始一直往里面，直到点击的元素才停止</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>事件冒泡: documet -&gt; html -&gt; body -&gt; div -&gt; button</li></ul><blockquote><p>如上，再点击click之后，事件从 documet 开始传播至 button。这一个过程也称为事件捕获</p></blockquote><h2 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h2><blockquote><p>在上述两种事件确定的方式下，规定了事件处理的三个阶段。事件捕获阶段、处于目标阶段、事件冒泡阶段。同时 DOM明确规定</p></blockquote><ul><li><p>事件捕获阶段不会处理事件</p></li><li><p>处于目标阶段属于冒泡阶段的一部分，并且会触发事件。</p></li><li><p><strong>然而实际上，几乎所有主流浏览器都支持在事件捕获阶段触发事件，它们并没有遵守规定</strong></p></li></ul><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><blockquote><p>主要是指 DOM 如何处理各种 HTML 上的程序。</p></blockquote><blockquote><p>对于所有浏览器来说，有两种标准用来操作事件的添加与删除，一种是 DOM2 事件处理程序，一种是 IE 事件处理程序。</p></blockquote><h2 id="DOM2-级事件处理"><a href="#DOM2-级事件处理" class="headerlink" title="DOM2 级事件处理"></a>DOM2 级事件处理</h2><blockquote><p>直接调用该 dom 对象的事件属性，并将相应的执行函数赋予它</p></blockquote><h3 id="addEventListener-和-dom-on-事件-函数"><a href="#addEventListener-和-dom-on-事件-函数" class="headerlink" title="addEventListener() 和 dom.on(事件) &#x3D; 函数"></a>addEventListener() 和 dom.on(事件) &#x3D; 函数</h3><blockquote><p>利用 dom 对象的事件属性直接赋予一个执行函数；利用 addEventListener 添加，并且该方法可以添加多个</p></blockquote><blockquote><p>addEventListener() 有三个参数，参数 1 为事件、参数 2 为执行函数。参数 3 为一个布尔值，false 代表在冒泡阶段执行，true 表示在捕获阶段执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">doc.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="removeEventListener-和-dom-on-事件-null"><a href="#removeEventListener-和-dom-on-事件-null" class="headerlink" title="removeEventListener() 和 dom.on(事件) &#x3D; null"></a>removeEventListener() 和 dom.on(事件) &#x3D; null</h3><blockquote><p>利用直接设置事件属性为 null 来移出执行函数。利用 removeEventListener() 来移出，但前提是必须给定函数名</p></blockquote><blockquote><p>removeEventListener() 有三个参数，参数 1 为事件、参数 2 为执行函数。参数 3 为一个布尔值，false 代表在冒泡阶段执行，true 表示在捕获阶段执行</p></blockquote><blockquote><p>如下使用匿名函数定义的执行函数无法删除</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)<span class="comment">//通过匿名函数定义的</span></span><br><span class="line">doc.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);<span class="comment">//无效</span></span><br><span class="line">doc.<span class="property">onclick</span> = <span class="literal">null</span>;<span class="comment">//有效</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Click</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title class_">Click</span>, <span class="literal">false</span>)<span class="comment">//</span></span><br><span class="line">doc.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title class_">Click</span>, <span class="literal">false</span>);<span class="comment">//有效</span></span><br></pre></td></tr></table></figure><h2 id="IE-级"><a href="#IE-级" class="headerlink" title="IE 级"></a>IE 级</h2><h3 id="attachEvent"><a href="#attachEvent" class="headerlink" title="attachEvent()"></a>attachEvent()</h3><blockquote><p>和 DOM 2 级一样用来添加事件，只有两个参数 “事件” 和 “处理函数”，不能设置冒泡或者捕获。因为 IE8 之前那只支持冒泡，所以就只能冒泡</p></blockquote><blockquote><p>同样可以添加多个执行函数</p></blockquote><h3 id="detachEvent"><a href="#detachEvent" class="headerlink" title="detachEvent()"></a>detachEvent()</h3><blockquote><p>和 DOM2 级一样，要删除必须给定函数名作为参数。无法删除通过匿名定义添加的执行函数。</p></blockquote><h3 id="封装跨浏览器的事件处理函数"><a href="#封装跨浏览器的事件处理函数" class="headerlink" title="封装跨浏览器的事件处理函数"></a>封装跨浏览器的事件处理函数</h3><blockquote><p>因为 IE 独树一帜，又因为 IE 属于 windows 用户标配；所以兼容需要考虑。否则代码在 IE 上可能出问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventHandle</span> = &#123;</span><br><span class="line">  <span class="attr">addEvent</span>: <span class="function">(<span class="params">element, type, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">addEventListener</span>(type, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">attachEvent</span>(type, fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">`on<span class="subst">$&#123;type&#125;</span>`</span>] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="function">(<span class="params">element, type, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(type, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">detachEvent</span>(type, fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">`on<span class="subst">$&#123;type&#125;</span>`</span>] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">T</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">EventHandle</span>.<span class="title function_">addEvent</span>(doc, <span class="string">&#x27;click&#x27;</span>, T);</span><br><span class="line"><span class="title class_">EventHandle</span>.<span class="title function_">removeEvent</span>(doc, <span class="string">&#x27;click&#x27;</span>, T);</span><br></pre></td></tr></table></figure><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><blockquote><p>事件对象作为事件发生给予 js 获得相关信息的机会非常重要。程序要根据这些信息作出相应的响应。</p></blockquote><h2 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h2><blockquote><p>必定会传一个 event 对象给执行函数。可以直接作为参数使用。但有两种情况需要注意</p></blockquote><ul><li>通过直接在 html 元素上添加的事件，必须写明参数为 event，响应执行函数也要写明该参数</li><li>通过 addEventListener() 添加的事件，只需要在执行函数上写明参数就行。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;Test(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;header&#x27;</span>);</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">tagName</span>,event.<span class="property">type</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><ul><li>bubbles  Boolean 表明事件能否冒泡</li><li>cancelable Boolean 是否能取消事件的默认行为</li><li>currentTarget Element 当前事件处理程序正在处理的元素</li><li>defaultPrevented Boolean 为 true 表示调用了 preventDefault()</li><li>eventPhase Integer 1 为捕获阶段 - 2 - 为处于目标阶段 - 3 为冒泡阶段</li><li>preventDefault() 取消事件的默认行为，前提是 cancleable 为 true</li><li>target 事件的目标，就是触发事件的对象</li><li>type 事件类型</li></ul><h3 id="target-与-currentTarget"><a href="#target-与-currentTarget" class="headerlink" title="target 与 currentTarget"></a>target 与 currentTarget</h3><blockquote><p>这里的 currentTarget 是指发生事件时，该事件所绑定的那个元素</p></blockquote><blockquote><p>而 target 从始至终就都是你点击或者移动或者其他触发事件行为的元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;father(event)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;son(event)&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">father</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, event.<span class="property">currentTarget</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">son</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, event.<span class="property">currentTarget</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>看上述这个例子。</p></blockquote><ul><li><p>情况一：点击 button 2；按照事件冒泡那么两个执行函数都会触发</p><ul><li>target: 两个函数的输出值都为 button 2；因为点击的是该元素</li><li>currentTarge: son() 输出的为 button 1；father() 输出为 div</li></ul></li><li><p>情况二：点击 button 1；只会触发 father()</p><ul><li>target: 输出为 button 1；因为就是点击在 button 1 上</li><li>currentTarget：输出为 div；因为该执行函数就绑定在该元素上</li></ul></li><li><p>情况三：点击 div；只触发 father()</p></li><li><p>target 和 currentTarget 都为 div</p></li></ul><blockquote><p>另外，执行函数中的 this 值指向 currentTarget；<strong>但是有个前提，this值要等于 currentTarget,那么必须是在target上或者事件是通过 sddEventListener 添加的。否则通过html元素直接绑定的方式this指向了 window 对象</strong></p></blockquote><h3 id="eventPhase-和-stopPropagation"><a href="#eventPhase-和-stopPropagation" class="headerlink" title="eventPhase 和 stopPropagation"></a>eventPhase 和 stopPropagation</h3><blockquote><p>eventPhase 可以知道事件执行时处于哪个阶段</p></blockquote><blockquote><p>stopPropagation 可以阻值事件继续冒泡传播。我们知道一般事件是在处于目标阶段到冒泡阶段执行的。倘若不阻止冒泡，那么点击一个小按钮，一直回溯到 document。那么整个页面许多地方的点击事件都会触发，很显然我们不想这样。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;father(event)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;son(event)&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">father</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, event.<span class="property">currentTarget</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">son</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, event.<span class="property">currentTarget</span>, event.<span class="property">eventPhase</span>);<span class="comment">//button button 2</span></span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">stopPropagation</span>();<span class="comment">//阻止继续冒泡。这样就不会触发 father 了</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当然该方法同样可以阻止捕获，不过前提是绑定事件时指定他在捕获阶段触发。这样一来就不会继续捕获下去了</p></blockquote><h2 id="IE-事件对象"><a href="#IE-事件对象" class="headerlink" title="IE 事件对象"></a>IE 事件对象</h2><p>为什么不能统一呢，非要学两套</p><blockquote><p>IE 事件对象与 DOM 级有一定差异</p></blockquote><h3 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h3><ul><li>cancelable 默认值为 false，true 为取消冒泡。与 DOM 中 stopPropagation 相似</li><li>returnValue 默认为 true，false 为取消事件默认行为，与 DOM 中 preventDefalut() 相似</li><li>srcElement 事件目标，与 DOM target 相似</li><li>type 事件类型</li></ul><h3 id="event-对象的获取"><a href="#event-对象的获取" class="headerlink" title="event 对象的获取"></a>event 对象的获取</h3><blockquote><p>IE 中的 event 对象时作为 window 对象的一部分存在，可以通过 window.event 来获取</p></blockquote><ul><li>通过文档对象赋值的方法，必须要指定 window.event ，直接使用 event 会报错 undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#id&#x27;</span>);</span><br><span class="line">doc.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);<span class="comment">//event undefined</span></span><br><span class="line">  <span class="keyword">var</span> event = <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);<span class="comment">//click</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 attachEvent() 添加的可以像 DOM 那样作为参数直接使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc.<span class="title function_">attachEvent</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);<span class="comment">//click</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>执行函数中关于事件元素的信息都可以通过 event 获取，虽然 this 值有时也会等于 event 的部分属性。但是建议用 event，因为 this 的指向取决于外部执行环境，不能保证得到想要的值。</p></blockquote><blockquote><p><strong>另外，IE 要没了。取而代之的是微软新浏览器 Edge ，这个浏览器好像已经统一了 DOM级规定的事件处理。原来 IE 的那些特有事件处理已经没有了</strong></p></blockquote><h1 id="事件Type"><a href="#事件Type" class="headerlink" title="事件Type"></a>事件Type</h1><blockquote><p>常见的事件类型</p></blockquote><h2 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h2><blockquote><p>界面发生的事件</p></blockquote><h3 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h3><blockquote><p>当页面完全加载，包括所有图像、js 文件、产生式文件等外部资源。之后就会触发该事件。<strong>添加事件的方法？建议使用之前写的跨浏览器事件处理方法。当然也可以通过获取 dom 对象，并对其属性赋值，也可以直接在 html 元素上绑定。但是这两个方法下的 event 对象的使用有区别，特别是在 IE 浏览器上</strong></p></blockquote><ul><li>在 window对象下触发整个页面的加载；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;加载完毕&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>用来加载图片</li></ul><blockquote><p>绑定事件后，设置 img 的 src 即刻加载。可以用来做图片的预加载。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">image.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;图像加载完毕&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;页面加载完毕，开始加载图像&#x27;</span>);</span><br><span class="line">  image.<span class="property">src</span> = <span class="string">`https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1599126757461&amp;di=2d244dfca72c7e4c96e533c37d520b43&amp;imgtype=0&amp;src=http%3A%2F%2Fattach.bbs.miui.com%2Fforum%2F201307%2F25%2F201849gw2fgom557bg25jz.jpg`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>用来加载 js 外部文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> js = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">js.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;js加载完毕&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;页面加载完毕，开始加载js&#x27;</span>);</span><br><span class="line">  js.<span class="property">src</span> = <span class="string">`./xxx.js`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a>unload 事件</h3><blockquote><p>与 load 事件相反，一般页面切换后触发，可用来强制的引用清除，防止内存泄漏</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;跳转了&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a>resize 事件</h3><blockquote><p>当页面大小发生改变时触发，可以用此来获取一些窗口属性，用来做响应式开发。但是大小改变检测很灵敏，所以需要做防抖</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大小改变&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="scroll-事件"><a href="#scroll-事件" class="headerlink" title="scroll 事件"></a>scroll 事件</h3><p><strong>scrollLeft 和 scrollTop</strong></p><blockquote><p>这是存在于 document 上的两个属性，分别代表滚动条已经滚动的高度和宽度。他们与 clientWidth 、clienHeight一样都是页面视口的属性，并非整个浏览器创口属性。</p></blockquote><blockquote><p>该事件是在 window 对象上发生的，与 scrollTop，scrollLeft 有关。监听该事件可以用来做导航栏的变化，同样要做防抖，否则容易卡顿</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;滚动&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>, <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><blockquote><p>焦点一般只鼠标的焦点，虽然可以检测鼠标事件来监控，但是焦点可以通过键盘移动所以有专门的事件监控。焦点事件标准不一，但是 DOM3 统一了一个标准并且规定了它的发生顺序</p></blockquote><blockquote><p>当一个元素移动到另一个元素会依次触发以下事件;一般 blur 与 focus 常见</p></blockquote><ul><li>focusout 在失去焦点元素上触发，会冒泡</li><li>focusin 在获取焦点元素上触发，会冒泡</li><li>blur 在失去元素上触发，不会冒泡</li><li>DOMFocusOut 在失去焦点元素上触发，会冒泡; Opera 专有</li><li>focus 在获取焦点元素上触发，不会冒泡</li><li>DOMFocusIn 在获取焦点元素上触发，会冒泡; Opera 专有</li></ul><h2 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h2><h3 id="鼠标点击与移动"><a href="#鼠标点击与移动" class="headerlink" title="鼠标点击与移动"></a>鼠标点击与移动</h3><blockquote><p>主要是点击、双击、光标移入、移出、暗下、放开的操作；</p></blockquote><ul><li>mouseenter 首次移入元素内部触发，不冒泡</li><li>mouseleave ，移出元素触发，不冒泡</li><li>mousemove 在元素内重复移动触发</li><li>mouseout 移入另一个元素触发</li><li>mousedown 按下鼠标触发</li><li>mouseup 释放鼠标按键触发</li><li>click 点击，只有按下事件和放开事件发生后才会触发，只是按下不会触发</li><li>dblclick 双击，当且仅当连续两次 click 时触发</li></ul><blockquote><p>触发顺序：</p></blockquote><ul><li>mousedown</li><li>mouseup</li><li>click &#x2F;&#x2F;一次点击</li><li>mousedown</li><li>mouseup</li><li>click &#x2F;&#x2F;二次点击</li><li>dblclick &#x2F;&#x2F;触发双击</li></ul><blockquote><p>一般可以用于轮播图或者自动播放，当鼠标移入将其停止，移出又自动播放</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;暂停&#x27;</span>)&#125; )</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>)&#125; )</span><br></pre></td></tr></table></figure><h3 id="滚轮"><a href="#滚轮" class="headerlink" title="滚轮"></a>滚轮</h3><ul><li>mousewheel</li></ul><blockquote><p>可用于获取该事件发送时鼠标属性，在任何元素上通过鼠标滚动即可触发。可以检测页面滚动是否来自鼠标。该事件冒泡。</p></blockquote><h3 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h3><blockquote><p>上述事件在移动端上又有所不同</p></blockquote><ul><li>并不支持 dblclick ，双击只会放大</li><li>轻击不可单击或者没有绑定 click 的元素什么事件也不会发生</li><li>在可点击或者绑定 click 的前提下点击会触发 mousemove 。若该事件改变了内容将不会在发生其他事件，否则可以发生 down、up、click 事件</li><li>mousemove 也会触发 mouseenter 和 mouseout</li><li>手指滚动页面时会触发 mousewheel 和 scroll 事件</li></ul><h2 id="键盘和文本事件"><a href="#键盘和文本事件" class="headerlink" title="键盘和文本事件"></a>键盘和文本事件</h2><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><ul><li>keydown 敲击任意键时触发，若按住不放则不断触发</li><li>keypress 敲击字符健时触发，若按住不放则不断触发</li><li>keyup 释放键盘触发</li></ul><blockquote><p>按下字符键时依次触发 keydown -&gt; keypress -&gt; keyup<br>按下非字符键时依次触发 keydown -&gt; keyup</p></blockquote><blockquote><p>另外发生 keydown 和 keyup 时，也可以通过 event 对象获取相应的键值(ASCII码值)。keyCode</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">keyCode</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="textInput-事件"><a href="#textInput-事件" class="headerlink" title="textInput 事件"></a>textInput 事件</h3><blockquote><p>触发条件</p></blockquote><ul><li>必须在可编辑区编辑</li><li>输入实际字符的键，不会包括删除、退格键等等</li></ul><blockquote><p>可以通过 event.data 获得键盘实际输入值而非 ASCII 码值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;textInput&#x27;</span>,<span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h2><blockquote><p>设备事件不是值页面内的事件，而是移动设备本身事件，比如翻转、是否走动。目前的草案中有四种类型事件</p></blockquote><ul><li><p>orientationchange ，苹果给 safari 添加的事件用来检测设备从横向观察模式到纵向观察模式。</p></li><li><p>它的值存在于 window.orientation 中。0 为纵向、90 为向左旋转、-90 为向右旋转</p></li><li><p>MozOrientation ，firefox 未检测设备而引入，依靠 event 的 x,y,z 来确定方向。该事件可能被替代</p></li><li><p>deviceorientation</p></li><li><p>devicemotion</p></li></ul><h2 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h2><blockquote><p>这一类事件是移动设备的事件核心</p></blockquote><h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><ul><li>touchstart 手指触摸屏幕触发</li><li>touchmove 手指在屏幕上连续滑动触发。可以调用 preventDefault() 来阻值滑动</li><li>touchend 手指离开屏幕</li><li>touchcancel 系统停止跟踪触发</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这一概念源自于对事件触发对象的思考。例如常见的点击事件，鼠标移动事件。这些事件发生之时，往往不只是点击或者移动到某一特定元素上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;比如点击某一个按钮，而它是由上一层的父标签，或许在上一层还有父标签甚至是整个页面。因此点击一个元素可以看成是同时点击了父标签或者整个页面。那么此时事件应该怎么响应到指定标签呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>D3jsView</title>
    <link href="http://example.com/2020/09/04/interview/D3jsView/"/>
    <id>http://example.com/2020/09/04/interview/D3jsView/</id>
    <published>2020-09-04T09:12:02.000Z</published>
    <updated>2020-09-04T09:12:52.646Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>reactView</title>
    <link href="http://example.com/2020/09/04/interview/reactView/"/>
    <id>http://example.com/2020/09/04/interview/reactView/</id>
    <published>2020-09-04T09:11:41.000Z</published>
    <updated>2020-09-04T09:12:40.979Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vueView</title>
    <link href="http://example.com/2020/09/04/interview/vueView/"/>
    <id>http://example.com/2020/09/04/interview/vueView/</id>
    <published>2020-09-04T09:11:27.000Z</published>
    <updated>2020-10-30T12:08:08.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>根据面试经历整理的 Vue 面试题</p></blockquote><span id="more"></span><h1 id="几大生命周期"><a href="#几大生命周期" class="headerlink" title="几大生命周期"></a>几大生命周期</h1><h1 id="Vue-的源码看过吗？双向数据绑定用什么？"><a href="#Vue-的源码看过吗？双向数据绑定用什么？" class="headerlink" title="Vue 的源码看过吗？双向数据绑定用什么？"></a>Vue 的源码看过吗？双向数据绑定用什么？</h1><h1 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h1><h1 id="watch-和-computed-的区别"><a href="#watch-和-computed-的区别" class="headerlink" title="watch 和 computed 的区别"></a>watch 和 computed 的区别</h1><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><blockquote><p>顾名思义，计算属性，主要用于一些依赖于 data 数据的简单处理，比如数值计算、数组剪切、字符串过滤这种一个表达式就能解决的问题。</p></blockquote><blockquote><p>computed 默认为 getter 方法，也就是 return 一个表达式，当这个表达式里面含有 data 中定义的数据时，那么这一个computed 方法都是响应式的，在数据变化时，它会再次调用进行 return 操作</p></blockquote><blockquote><p>computed 属性第一次计算时会保留计算的值，当它其中所依赖的响应式数据变化时，它会判断该响应式的值是否发生变化，若是与上一次一样，则无需在次计算，直接返回上次存储的计算结果；反之就要再次调用 return 整个计算的表达式得到新的值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">msssage</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">display</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="property">length</span> &gt; <span class="number">50</span> ? <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">49</span>) : <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><blockquote><p>同样用来监听数据，并作出改变。</p></blockquote><blockquote><p>不同于 computed ，computed 可以用于一个 return 就能解决的问题，但是遇到需要根据响应式数据改变而调用某个方法或者发起 ajax 请求，那么 watch 更合适</p></blockquote><blockquote><p>watch 可以拿到新的值与旧的值，并且可以根据值的变化来进行异步请求或者复杂处理，这是 computed 很难做到的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">msssage</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">display</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="property">length</span> &gt; <span class="number">50</span> ? <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">49</span>) : <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(val.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getMsg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">getMsg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">message</span> = res,</span><br><span class="line">        <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;error&#x27;</span></span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h1><h1 id="路由、多视图"><a href="#路由、多视图" class="headerlink" title="路由、多视图"></a>路由、多视图</h1><h1 id="Vuex-如何更新数据"><a href="#Vuex-如何更新数据" class="headerlink" title="Vuex 如何更新数据"></a>Vuex 如何更新数据</h1><h1 id="虚拟-DOM-树最终如何更新到真实-dom-树"><a href="#虚拟-DOM-树最终如何更新到真实-dom-树" class="headerlink" title="虚拟 DOM 树最终如何更新到真实 dom 树"></a>虚拟 DOM 树最终如何更新到真实 dom 树</h1><h1 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h1><h1 id="Vuex-和-Vue-Router-的常见-API-及其用法"><a href="#Vuex-和-Vue-Router-的常见-API-及其用法" class="headerlink" title="Vuex 和 Vue-Router 的常见 API 及其用法"></a>Vuex 和 Vue-Router 的常见 API 及其用法</h1><!-- more -->]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;根据面试经历整理的 Vue 面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>css 布局基础</title>
    <link href="http://example.com/2020/09/03/css/cssLayout/"/>
    <id>http://example.com/2020/09/03/css/cssLayout/</id>
    <published>2020-09-03T14:41:57.000Z</published>
    <updated>2021-05-04T10:16:34.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><blockquote><p>要了解css的布局，就要先了解什么是文档流。文档流就是HTML元素的一种排列规则。</p></blockquote><span id="more"></span><blockquote><p>而正常文档流就是在不用样式控制之下，html元素的默认排版方式。它的规则如下：</p></blockquote><ul><li>自上而下排列，每个块元素独占一行，行内元素自左向右排列，不会独占一行</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>独占一行<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">从左向右<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这是在不使用 样式的请况之下正常排列方式。倘若使用样式改变了某些元素的位置，那么就称为脱离文档流。也正是因为如此，才能有丰富的页面布局方式。否则大家都只是遵循上述两种方式，那就太枯燥单一了。</p></blockquote><h1 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h1><blockquote><p>float属性，一般情况下元素默认是不浮动的，一旦添加该属性，元素就会向右或者向左浮动。看例子</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">2px</span> rebeccapurple solid;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">3px</span> greenyellow solid;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.float</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* height: 100px; */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.float</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> blue solid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.float</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.float</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> green solid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>不会导致高度塌陷<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是正常流文字文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>box1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>box2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>box3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是浮动文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>经过对比可以发现，在不使用浮动之前，三个盒子都按照块元素的正常文档流排列方式，并且父元素的高也随着他们的内容大小变化。而一旦使用了浮动元素。会发现几点变化：</p></blockquote><ul><li>三个盒子的块元素变为了行内元素的排列方式，按照浮动属性值自左向右</li><li>父元素的高度不在随他们变化，直接没有了高度，当然他们依然相对于父元素排列，只是没有将其撑开</li></ul><blockquote><p>这里也引入一个问题</p></blockquote><h2 id="父元素高度坍塌"><a href="#父元素高度坍塌" class="headerlink" title="父元素高度坍塌"></a>父元素高度坍塌</h2><blockquote><p>出现于上述的那种情况，因为那三个盒子脱离了文档流。自己排布，他们虽然相对于父元素排布，但却不是父元素的正常文档流的内容，所以无法将其撑开，从而导致父元素的高度回缩，也就是坍塌。</p></blockquote><h2 id="文字环绕浮动"><a href="#文字环绕浮动" class="headerlink" title="文字环绕浮动"></a>文字环绕浮动</h2><blockquote><p>虽然浮动元素脱离了文档流，但并不是不对正常流文档元素产生影响。上述例子中，虽然没有把父元素撑开，但是与它同级的兄弟元素并不会直接跑到它上面去，而是在它之下按照一下两个规则排列</p></blockquote><h3 id="若是浮动元素后紧跟-h1-h6、p"><a href="#若是浮动元素后紧跟-h1-h6、p" class="headerlink" title="若是浮动元素后紧跟 -&gt; h1 ~ h6、p"></a>若是浮动元素后紧跟 -&gt; h1 ~ h6、p</h3><blockquote><p>这一类段落标签会自动换行，并且自带内边距</p></blockquote><ul><li>这一类标签在页面中会紧贴在浮动元素下面 ( <strong>这个紧贴不是边框紧贴！而是段落标签中的文字紧贴浮动元素</strong> )，依然独占一行，并且里面的文字内容不会自动排到最左边，而是相对于最右边的浮动元素的后面</li></ul><h3 id="若是浮动元素后紧跟-其他块元素"><a href="#若是浮动元素后紧跟-其他块元素" class="headerlink" title="若是浮动元素后紧跟 -&gt; 其他块元素"></a>若是浮动元素后紧跟 -&gt; 其他块元素</h3><blockquote><p>这一类无论是否有内容，都不会排到浮动元素后面，而是直接相对于父元素按照正常文档流排列，好像是直接无视了之前的浮动元素一样，认为自己就是父元素之下的第一个子元素</p></blockquote><ul><li>同样若是这里面的文字与浮动元素有交集，那么也是按照之前的方式排列</li></ul><blockquote><p><strong>当然内边距，外边距，边框这些属性在浮动元素之间，仅仅是在它们之间是生效的。与其他正常文档流不产生效果</strong></p></blockquote><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><blockquote><p>嗯？为什么还要清除浮动？直接不浮动就行了啊？</p></blockquote><blockquote><p>其实这是给浮动元素之后的元素用的，并不是给浮动元素本省用的；之所以要这样，是因为紧跟在浮动元素后面的普通元素都会受到影响。就比如上述说的两种紧跟浮动元素之后排列的方式。我能不能让它不要忽视浮动元素，而是排在浮动元素之后呢？能不能让段落标签不这么紧贴着，而是以边框为基准排在浮动元素后面呢？答案是肯定的。</p></blockquote><ul><li>**使用 claer: both; clear: left; clear: right;**就可以</li><li>使用之后紧跟在浮动元素之后的就不会乱排布，而是按正常文档流排布，不过是排在了浮动元素后面，就好似把浮动元素看成了普通的行内元素一样，不会无视它，也不会覆盖它了。</li></ul><h1 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h1><blockquote><p>这也是脱离文档流的一种方式，它通过显式的设置定位坐标及大小来实现</p></blockquote><h2 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position:fixed"></a>position:fixed</h2><blockquote><p>这个比较简单，是相对于浏览器而言，导航栏通常就这么用；直接脱离文档流，别的元素将会无视它并且挤上来</p></blockquote><h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position:relative"></a>position:relative</h2><blockquote><p>相对于原来的位置定位，原来位置就是正常文档流的位置。而且周边元素不会挤上来，看似好像是它已经走了，但是原来的位置还完好无损的留着。</p></blockquote><h2 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position:absolute"></a>position:absolute</h2><blockquote><p>绝对定位，也是直接脱离文档流，别的元素将会无视它并且挤上来</p></blockquote><h2 id="position-static"><a href="#position-static" class="headerlink" title="position:static"></a>position:static</h2><blockquote><p>默认定位，也是每一个元素的初始定位，也就是正常文档流</p></blockquote><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><blockquote><p>这个东西其实不是一个规范的知识点，它是一个规则概念。为了解决普通元素与普通元素之间，普通元素与浮动元素之间产生的属性混乱问题</p></blockquote><blockquote><p>它的定义就是，<strong>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong></p></blockquote><blockquote><p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p></blockquote><h2 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h2><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文档流&quot;&gt;&lt;a href=&quot;#文档流&quot; class=&quot;headerlink&quot; title=&quot;文档流&quot;&gt;&lt;/a&gt;文档流&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;要了解css的布局，就要先了解什么是文档流。文档流就是HTML元素的一种排列规则。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="布局" scheme="http://example.com/tags/%E5%B8%83%E5%B1%80/"/>
    
    <category term="浮动布局" scheme="http://example.com/tags/%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
    <category term="flex" scheme="http://example.com/tags/flex/"/>
    
    <category term="文档流" scheme="http://example.com/tags/%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的 class</title>
    <link href="http://example.com/2020/09/02/es6/classES6/"/>
    <id>http://example.com/2020/09/02/es6/classES6/</id>
    <published>2020-09-02T12:36:29.000Z</published>
    <updated>2020-09-03T07:03:35.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>es5 的构造函数、原型链等等的写法，其实是不太符合类的规范的，并且之前有过 oop 语言基础的人来学习，也会发现很奇怪。所以 es6 引入了类的概念，在原生的层次上对函数进行了封装。</p></blockquote><span id="more"></span><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>而到了 class 可以这么写</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Great</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很明显变得更加有逻辑了</p></blockquote><h2 id="constructor-和-原型方法"><a href="#constructor-和-原型方法" class="headerlink" title="constructor 和 原型方法"></a>constructor 和 原型方法</h2><ul><li>相当于是原来的构造函数，它是每一个实例拥有的一份独有属性。如果没有显示定义会自动生成一个空的 constructor 方法</li><li>除了 constructor 之外的 class 内部函数都是定义在该类上的原型对象</li><li>class 是对构造函数的一种原生封装，它们的一些行为是相同的</li><li><strong>必须通过 new 操作符来创建实例</strong></li></ul><h3 id="本身是构造函数"><a href="#本身是构造函数" class="headerlink" title="本身是构造函数"></a>本身是构造函数</h3><ul><li><strong>定义在内部的方法是无法被枚举的，这与ES5不一样</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Great</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grt = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;t&#x27;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grt.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);</span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, getName: ƒ&#125;</span></span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, getName: ƒ&#125;</span></span><br><span class="line"><span class="comment">// class Great &#123;</span></span><br><span class="line"><span class="comment">//   constructor(name, age) &#123;</span></span><br><span class="line"><span class="comment">//     this.name = name;</span></span><br><span class="line"><span class="comment">//     this.age = age;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   getName() &#123;</span></span><br><span class="line"><span class="comment">//     return this.name;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(grt.<span class="property">__proto__</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(grt));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(grt.<span class="property">__proto__</span>));</span><br><span class="line"><span class="comment">//[]</span></span><br><span class="line"><span class="comment">//(2) [&quot;name&quot;, &quot;age&quot;]</span></span><br><span class="line"><span class="comment">//(2) [&quot;constructor&quot;, &quot;getName&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到他就是构造函数，原型有 constructor 用来指向构造函数本身，构造函数和实例对象有 prototype 和 __proto__ 用来指向原型</p></blockquote><h3 id="新的实例属性写法和属性表达式"><a href="#新的实例属性写法和属性表达式" class="headerlink" title="新的实例属性写法和属性表达式"></a>新的实例属性写法和属性表达式</h3><blockquote><p>新写法特指 constructor 里面的一些常量，如果是靠参数传递那么还是要使用 constructor 的</p></blockquote><blockquote><p>属性表达式值方法名可以使用表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fname = <span class="string">&#x27;getArea&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Great</span> &#123;</span><br><span class="line">  area = <span class="string">&#x27;中国&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  [fname]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> grt = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;tzw&#x27;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grt.<span class="property">area</span>)</span><br><span class="line"><span class="comment">//中国</span></span><br></pre></td></tr></table></figure><h3 id="存值函数和取值函数、"><a href="#存值函数和取值函数、" class="headerlink" title="存值函数和取值函数、"></a>存值函数和取值函数、</h3><blockquote><p>这个对应了对象当中属性的访问器属性 get 与 set，在类里面可以直接定义他们用来设置拦截。就如同使用 Object.defineProperty() 来设置拦截一样</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Great</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setter：<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> grt = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">grt.<span class="property">name</span> = <span class="string">&#x27;tzw&#x27;</span>;</span><br><span class="line"><span class="comment">//setter：tzw</span></span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><blockquote><p>静态方法只能通过类直接调用，实例是不可以的.只要加上 <strong>static</strong> 就可以</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Great</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> grt = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="title class_">Great</span>.<span class="title function_">sayHello</span>();</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line">grt.<span class="title function_">sayHello</span>();</span><br><span class="line"><span class="comment">//Uncaught TypeError: grt.sayHello is not a function</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;es5 的构造函数、原型链等等的写法，其实是不太符合类的规范的，并且之前有过 oop 语言基础的人来学习，也会发现很奇怪。所以 es6 引入了类的概念，在原生的层次上对函数进行了封装。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="ES6" scheme="http://example.com/categories/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="class" scheme="http://example.com/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络面经</title>
    <link href="http://example.com/2020/09/01/interview/csNetWork/"/>
    <id>http://example.com/2020/09/01/interview/csNetWork/</id>
    <published>2020-09-01T14:29:54.000Z</published>
    <updated>2020-10-30T15:08:30.334Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="get-和-post-区别"><a href="#get-和-post-区别" class="headerlink" title="get 和 post 区别?"></a>get 和 post 区别?</h1><h1 id="七层网络-OSI"><a href="#七层网络-OSI" class="headerlink" title="七层网络 OSI"></a>七层网络 OSI</h1><h1 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h1><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><h1 id="HTTP-1-0-和-HTTP-2-0-相比"><a href="#HTTP-1-0-和-HTTP-2-0-相比" class="headerlink" title="HTTP 1.0 和 HTTP 2.0 相比"></a>HTTP 1.0 和 HTTP 2.0 相比</h1><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><h1 id="HTTP-常见头部字段"><a href="#HTTP-常见头部字段" class="headerlink" title="HTTP 常见头部字段"></a>HTTP 常见头部字段</h1><h1 id="HTTPS-的加密"><a href="#HTTPS-的加密" class="headerlink" title="HTTPS 的加密"></a>HTTPS 的加密</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;get-和-post-区别&quot;&gt;&lt;a href=&quot;#get-和-post-区别&quot; class=&quot;headerlink&quot; title=&quot;get 和 post 区别?&quot;&gt;&lt;/a&gt;get 和 post 区别?&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>javaScript面经</title>
    <link href="http://example.com/2020/08/31/interview/javaScriptView/"/>
    <id>http://example.com/2020/08/31/interview/javaScriptView/</id>
    <published>2020-08-31T14:21:47.000Z</published>
    <updated>2020-10-30T15:09:08.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><blockquote><p>作用域就是程序执行到某一个特定部分时，可以访问这一部分的变量或者函数，这些变量或者函数就组成了一个特定的域，称为作用域。</p></blockquote><span id="more"></span><blockquote><p>程序执行会有一个环境栈，从全局环境开始，生成一个全局执行环境的关联对象，该对象拥有全局作用域的所有变量和方法。然后程序继续执行，遇到函数，也会生成该函数的一个关联的环境对象，并且将它压入栈中，此时会根据环境栈生成一个作用链，栈顶（作用域链顶端）也就是当时的函数执行环境对象，查找变量时就可以从作用域链顶端开始一直往后。</p></blockquote><blockquote><p>每一个执行环境都有一个作用域链，他可以访问作用域链上的属性和方法</p></blockquote><h1 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h1><blockquote><p>为什么要有原型。因为原本的构造函数，工厂模式产生的实例不能共享方法，非常浪费内存。</p></blockquote><h1 id="测试类型、数组类型"><a href="#测试类型、数组类型" class="headerlink" title="测试类型、数组类型"></a>测试类型、数组类型</h1><blockquote><p>typeof 可以测试基本类型值，引用类型值只能测出 object<br>instanceof 可以测所有类型的值，包括是哪种引用类型值<br>constructor 该属性是属于原型的属性，指向了其构造原型的构造函数<br>Object.prototype.toString.call() 对象拥有的原型方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(<span class="number">11</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(<span class="string">&quot;yes&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">call</span>(<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;))</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>一种延长作用域链的方式，通过函数中创建另一个函数并且引用函数内部的属性，当函数运行完之后，返回的匿名函数依然保存着对原来函数的属性引用，这个引用是通过作用域链来完成的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>, b = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> com = <span class="title class_">Great</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">com</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">com</span>());</span><br></pre></td></tr></table></figure><h1 id="null和undefine的区别"><a href="#null和undefine的区别" class="headerlink" title="null和undefine的区别"></a>null和undefine的区别</h1><blockquote><p>null 为空值，是一个空指针对象，通过 number 可以转为 0<br>undefined 是未定义，定义的变量没有初始化就会默认为这个值，通过 number 转为 NaN</p></blockquote><h1 id="call-apply-bind区别-，手写bind"><a href="#call-apply-bind区别-，手写bind" class="headerlink" title="call,apply,bind区别 ，手写bind"></a>call,apply,bind区别 ，手写bind</h1><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h1 id="函数和执行域相关"><a href="#函数和执行域相关" class="headerlink" title="函数和执行域相关"></a>函数和执行域相关</h1><blockquote><p>记住函数作用域以及 var 有变量提升</p></blockquote><h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><blockquote><p>实现诸如 add(1,3)(2) &#x3D; 6 的效果，利用闭包的特性来做</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">KeLi</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = [...arg];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newArgs.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">      args.<span class="title function_">push</span>(...newArgs);</span><br><span class="line">      <span class="keyword">return</span> add;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> pre += next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">KeLi</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)(<span class="number">1</span>,<span class="number">2</span>)(-<span class="number">13</span>,<span class="number">2</span>)())</span><br><span class="line"><span class="comment">//22</span></span><br></pre></td></tr></table></figure><h1 id="对node-js有了解吗"><a href="#对node-js有了解吗" class="headerlink" title="对node.js有了解吗"></a>对node.js有了解吗</h1><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h2 id="promise-all-方法"><a href="#promise-all-方法" class="headerlink" title="promise.all 方法"></a>promise.all 方法</h2><blockquote><p>每一个promise 实例变为 full ，最后的才会变为 full。否则遇到的第一个 reject ，就会返回该 reject。并且整个 Promise.all 会停止执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pro = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;e了&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(`触发成功$&#123;res&#125;`);</span></span><br><span class="line"><span class="comment">//   return res;</span></span><br><span class="line"><span class="comment">// &#125; , err =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(`触发错误$&#123;err&#125;`);</span></span><br><span class="line"><span class="comment">//   return err</span></span><br><span class="line"><span class="comment">// &#125; );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pro1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>;i &lt; <span class="number">10</span>;i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="title class_">Promise</span>.<span class="title function_">all</span>([pro, pro1]);</span><br><span class="line"></span><br><span class="line">sum.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`最终结果为成功<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`最终结果为错误<span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//最终结果为错误3</span></span><br></pre></td></tr></table></figure><blockquote><p>但是这里有一个点，如果在实例上有 then 方法，那么最终实例是接不到 err 回调函数的，因为在最终实例看来是成功的，并且整个 Promise.all 会执行完</p></blockquote><h2 id="自己实现一个-Promise-all-方法"><a href="#自己实现一个-Promise-all-方法" class="headerlink" title="自己实现一个 Promise.all 方法"></a>自己实现一个 Promise.all 方法</h2><h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始下一条&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yes&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">great</span>();</span><br></pre></td></tr></table></figure><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组扁平化方式一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flaten</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; array.<span class="property">length</span>;i ++) &#123;</span><br><span class="line">    clone = clone.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array[i]) ? <span class="title function_">flaten</span>(array[i]) : array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组扁平化方式二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flaten1</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = array;</span><br><span class="line">  <span class="comment">//console.log(clone.some(item =&gt; Array.isArray(item)));</span></span><br><span class="line">  <span class="keyword">while</span>(clone.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    clone = [].<span class="title function_">concat</span>(...clone);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6中的方法 flat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="string">&#x27;yes&#x27;</span>],&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;]];</span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flaten1</span>(y))</span><br></pre></td></tr></table></figure><h1 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h1><h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><ul><li>Array.isArray(x) 是数组就返回 true</li></ul><h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><ul><li>array[i]</li><li>array.indexOf(x)</li><li>array.lastIndexOf(x)</li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li>pop push</li><li>unshift shift</li><li>splice</li><li>slice</li><li>concat</li></ul><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><ul><li>sort() 传入一个函数作为比较条件</li><li>reverse() 翻转数组</li></ul><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><ul><li>some every</li><li>map filter</li><li>forEach</li><li>reduce 向后迭代</li><li>reduceRight 从后向前迭代</li></ul><p><strong>同花顺一面</strong></p><h1 id="Ajax-的基本使用"><a href="#Ajax-的基本使用" class="headerlink" title="Ajax 的基本使用"></a>Ajax 的基本使用</h1><p><strong>同花顺一面</strong></p><h2 id="创建-XHR-对象"><a href="#创建-XHR-对象" class="headerlink" title="创建 XHR 对象"></a>创建 XHR 对象</h2><blockquote><p>可以使用 new XMLHttpRequest(); 来创建</p></blockquote><blockquote><p>IE 7之前的要使用 new ActiveXObject(); 来创建</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="xhr-open-methods-url-boolean"><a href="#xhr-open-methods-url-boolean" class="headerlink" title="xhr.open(methods, url, boolean);"></a>xhr.open(methods, url, boolean);</h3><blockquote><p>如上所示，method 为请求方法，url 为请求地址，可加参数。布尔值表示是否要异步发送</p></blockquote><h3 id="xhr-send-null"><a href="#xhr-send-null" class="headerlink" title="xhr.send(null);"></a>xhr.send(null);</h3><blockquote><p>在成功调用 open 方法后，必须调用 send 方法才能开始发送。该方法接受一个参数，表示要在请求主体里面添加的数据，若是没有必须设置为空。</p></blockquote><h3 id="获取头部信息"><a href="#获取头部信息" class="headerlink" title="获取头部信息"></a>获取头部信息</h3><ul><li>getResponseHeader(params) 参数代表头部字段名称，函数返回相应头部字段对应的信息</li><li>getAllResponseHeaders() 获取所有头部字段包含的信息</li></ul><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><blockquote><p>使用 send 后必须监听响应或者错误</p></blockquote><ul><li>onreadystatechange() 监听状态码 state ，也就是 http 响应码</li><li>ontimeout 监听事件是否超时</li></ul><h1 id="事件捕获、冒泡、委托"><a href="#事件捕获、冒泡、委托" class="headerlink" title="事件捕获、冒泡、委托"></a>事件捕获、冒泡、委托</h1><p><strong>同花顺一面</strong></p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h1 id="dom-常见-api"><a href="#dom-常见-api" class="headerlink" title="dom 常见 api"></a>dom 常见 api</h1><blockquote><p>选择节点，创建节点，添加节点、删除节点</p></blockquote><h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><p><a href="https://www.jianshu.com/p/51a313f6c41d">请看这篇文章</a></p><h1 id="几大继承及最优继承"><a href="#几大继承及最优继承" class="headerlink" title="几大继承及最优继承"></a>几大继承及最优继承</h1><h1 id="this-set"><a href="#this-set" class="headerlink" title="this.$set"></a>this.$set</h1><h1 id="大数据渲染（documentFrame、虚拟列表）"><a href="#大数据渲染（documentFrame、虚拟列表）" class="headerlink" title="大数据渲染（documentFrame、虚拟列表）"></a>大数据渲染（documentFrame、虚拟列表）</h1><h1 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止短时间大量执行，等待动作结束在执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Jitter</span>(<span class="params">fn, sleep</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(fn, sleep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一定间隔内执行一次</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, sleep</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> valid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!valid) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>();</span><br><span class="line">      valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;, sleep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ScrollTop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> top = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title class_">Jitter</span>(<span class="title class_">ScrollTop</span>, <span class="number">500</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title function_">throttle</span>(<span class="title class_">ScrollTop</span>, <span class="number">500</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h1 id="nextTick-–Vue"><a href="#nextTick-–Vue" class="headerlink" title="nextTick() –Vue"></a>nextTick() –Vue</h1><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><blockquote><p>利用 assign 或者 “&#x3D;“ 进行浅拷贝</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;yes&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj);</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">34</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><blockquote><p>利用数组的 concat 和 slice 进行第一层深拷贝</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, [<span class="number">12</span>, <span class="number">13</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = obj.<span class="title function_">concat</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj.<span class="title function_">slice</span>();</span><br><span class="line">obj1.<span class="title function_">push</span>(<span class="number">34</span>);</span><br><span class="line">obj2[<span class="number">3</span>].<span class="title function_">push</span>(<span class="number">15</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj, obj1, obj2);</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><blockquote><p>利用 JOSN.stringify 和 JSON.parse 进行深拷贝。会过滤掉 undefined、function、symbol 这些值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;yes&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">34</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj,obj1);</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><blockquote><p>递归进行深拷贝</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="string">&quot;yes&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> clone = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      clone[key] = <span class="keyword">typeof</span> obj[key] == <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepClone</span>(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title function_">deepClone</span>(obj);</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">5</span>;</span><br><span class="line">obj1.<span class="property">d</span>[<span class="number">2</span>].<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj, obj1);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;作用域链&quot;&gt;&lt;a href=&quot;#作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域链&quot;&gt;&lt;/a&gt;作用域链&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作用域就是程序执行到某一个特定部分时，可以访问这一部分的变量或者函数，这些变量或者函数就组成了一个特定的域，称为作用域。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="前端面经" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="JS 面经" scheme="http://example.com/tags/JS-%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>html面经</title>
    <link href="http://example.com/2020/08/31/interview/htmlView/"/>
    <id>http://example.com/2020/08/31/interview/htmlView/</id>
    <published>2020-08-31T14:21:27.000Z</published>
    <updated>2021-05-04T10:15:44.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入-url-到显示页面？如何解析"><a href="#输入-url-到显示页面？如何解析" class="headerlink" title="输入 url 到显示页面？如何解析"></a>输入 url 到显示页面？如何解析</h1><h2 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h2><ul><li>先查看浏览器存储有没有记录</li><li>查看本地是否有记录</li><li>发送dns 请求到本地dns服务器查找，若是没有开始递归查询。</li><li>先到根服务器，然后根服务器会告诉本地dns应该像哪里的域服务器查找</li><li>到达域服务器，告诉本地服务器应该到哪里的域名服务器找</li><li>到达域名服务器找，返回相应的 ip 地址，并且本地dns服务器会保存该条记录，在下次查询时直接返回结果</li></ul><span id="more"></span><h2 id="建立-tcp-连接"><a href="#建立-tcp-连接" class="headerlink" title="建立 tcp 连接"></a>建立 tcp 连接</h2><ul><li>三次握手</li></ul><h2 id="发送http请求"><a href="#发送http请求" class="headerlink" title="发送http请求"></a>发送http请求</h2><ul><li>发送 http请求，服务器根据请求的详细地址返回相应的资源</li></ul><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><ul><li>开始解析 html 文档</li><li>构建 dom 树</li><li>并行下载 css文件，js 文件</li><li>执行 js 文件会阻塞 dom 树和 cssdom 树的构建，从而阻止渲染树的构建</li><li>css的执行也会阻塞 cssdom 树的构建从而阻塞渲染树的构建</li><li>只有当 dom 树和 cssdom 树构建完毕时，才会合并这两条树开始渲染渲染树</li><li>若是之后有修改 js 或者 css 的动作，则会触发回流和重绘</li></ul><h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h1 id="网页之间如何进行通信？"><a href="#网页之间如何进行通信？" class="headerlink" title="网页之间如何进行通信？"></a>网页之间如何进行通信？</h1><h1 id="同源策略和跨域解决"><a href="#同源策略和跨域解决" class="headerlink" title="同源策略和跨域解决"></a>同源策略和跨域解决</h1><h1 id="说一说-H5-新特性"><a href="#说一说-H5-新特性" class="headerlink" title="说一说 H5 新特性 ?"></a>说一说 H5 新特性 ?</h1><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><blockquote><p>新增 header,article,footer,section,nav 等等标签，这些标签从单词上看就能知道它的内容是什么。整体看起来像是一篇文章，比起一堆 div 更加有逻辑，更好理解。</p></blockquote><!-- more --><h2 id="新增-API"><a href="#新增-API" class="headerlink" title="新增 API"></a>新增 API</h2><h3 id="video-和-audio"><a href="#video-和-audio" class="headerlink" title="video 和 audio"></a>video 和 audio</h3><blockquote><p>audio 为音频，video 为视频，再过去都没有相关的标准来实现，现在有了这两种标准</p></blockquote><h3 id="浏览器存储-localstorege、sessionStroge、cookie"><a href="#浏览器存储-localstorege、sessionStroge、cookie" class="headerlink" title="浏览器存储 localstorege、sessionStroge、cookie"></a>浏览器存储 localstorege、sessionStroge、cookie</h3><ul><li>sessionStorage 会话存储，窗口之间不共享数据。窗口关闭数据就会消失。</li><li>localStorage 持久性存储，窗口之间共享数据，除非手动删除</li></ul><h3 id="canvas-和-svg"><a href="#canvas-和-svg" class="headerlink" title="canvas 和 svg"></a>canvas 和 svg</h3><blockquote><p>canvas 使用 JavaSvript 来进行画图<br>svg 使用 svg 元素来画图</p></blockquote><h3 id="webScoket"><a href="#webScoket" class="headerlink" title="webScoket"></a>webScoket</h3><blockquote><p>建立持久的双工通信，因为页面首次加载完成之后，tcp 就会断开，再次请求时，就会花费额外时间去建立 tcp 建立，所以 webScoket 可以建立持久的链接，减少因多次请求而浪费的时间</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;输入-url-到显示页面？如何解析&quot;&gt;&lt;a href=&quot;#输入-url-到显示页面？如何解析&quot; class=&quot;headerlink&quot; title=&quot;输入 url 到显示页面？如何解析&quot;&gt;&lt;/a&gt;输入 url 到显示页面？如何解析&lt;/h1&gt;&lt;h2 id=&quot;DNS-预解析&quot;&gt;&lt;a href=&quot;#DNS-预解析&quot; class=&quot;headerlink&quot; title=&quot;DNS 预解析&quot;&gt;&lt;/a&gt;DNS 预解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;先查看浏览器存储有没有记录&lt;/li&gt;
&lt;li&gt;查看本地是否有记录&lt;/li&gt;
&lt;li&gt;发送dns 请求到本地dns服务器查找，若是没有开始递归查询。&lt;/li&gt;
&lt;li&gt;先到根服务器，然后根服务器会告诉本地dns应该像哪里的域服务器查找&lt;/li&gt;
&lt;li&gt;到达域服务器，告诉本地服务器应该到哪里的域名服务器找&lt;/li&gt;
&lt;li&gt;到达域名服务器找，返回相应的 ip 地址，并且本地dns服务器会保存该条记录，在下次查询时直接返回结果&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端面经" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="html 面经" scheme="http://example.com/tags/html-%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>css面经</title>
    <link href="http://example.com/2020/08/31/interview/cssView/"/>
    <id>http://example.com/2020/08/31/interview/cssView/</id>
    <published>2020-08-31T12:16:38.000Z</published>
    <updated>2021-05-04T10:16:02.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>根据每个问题遇到的次数来进行排名</p></blockquote><h1 id="层叠样式"><a href="#层叠样式" class="headerlink" title="层叠样式"></a>层叠样式</h1><span id="more"></span><h1 id="position-和-z-index-的布局优先级"><a href="#position-和-z-index-的布局优先级" class="headerlink" title="position 和 z-index 的布局优先级"></a>position 和 z-index 的布局优先级</h1><h1 id="浮动布局和其他布局"><a href="#浮动布局和其他布局" class="headerlink" title="浮动布局和其他布局"></a>浮动布局和其他布局</h1><blockquote><p><a href="/css/cssLayout">看这里的文章</a></p></blockquote><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><blockquote><p>为了解决各中浮动以及 margin 导致的边距塌陷、合并问题</p></blockquote><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><blockquote><p>使其渲染规则发生改变</p></blockquote><ul><li>overflow: hidden;</li><li>float: left&#x2F;right;</li><li>display: inline-block;</li></ul><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>行内元素 display: inline-flex;</p></blockquote><blockquote><p>块状元素 display: flex;</p></blockquote><blockquote><p>设置 flex 之后，float 、clear、vertical-align 将会失效</p></blockquote><h2 id="父元素属性"><a href="#父元素属性" class="headerlink" title="父元素属性"></a>父元素属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><ul><li>row(水平排列，从左至右)默认</li><li>row-reverse(水平排列，从右至左)</li><li>column(垂直排列，从上至下)</li><li>column-reverse(垂直排列，从下至上)</li></ul><h3 id="flex-warp"><a href="#flex-warp" class="headerlink" title="flex-warp"></a>flex-warp</h3><ul><li>nowarp 默认不换行</li><li>warp 换行，第一行在上面</li><li>warp-reverse 换行，第一行在下面</li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><ul><li>上述两种情况的合并</li><li>默认 flex-flow: row nowarp;</li></ul><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><blockquote><p>水平方向的对齐方式</p></blockquote><ul><li>flex-start: 左对齐</li><li>flex-end: 右对齐</li><li>center: 居中</li><li>space-between: 两边对齐，中间等间隔</li><li>space-around: 所有元素间隔相等</li></ul><h3 id="align-item"><a href="#align-item" class="headerlink" title="align-item"></a>align-item</h3><blockquote><p>垂直方向对齐方式</p></blockquote><ul><li>flex-start: 向上对齐</li><li>flex-end: 向下对齐</li><li>center: 居中对齐</li><li>baseline: 根据文字底部对齐</li><li>stretch: 铺满</li></ul><h2 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><blockquote><p>排列顺序，越小排列月靠前</p></blockquote><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><blockquote><p>放大倍数</p></blockquote><h3 id="flex-shark"><a href="#flex-shark" class="headerlink" title="flex-shark"></a>flex-shark</h3><blockquote><p>缩小倍数，项目空间不足，自动缩小</p></blockquote><h3 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h3><blockquote><p>上面两种属性的缩写 flex: 0 0 auto;</p></blockquote><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><blockquote><p>某一个元素可以自定义对齐方式，值和垂直方向对齐方式的值一样</p></blockquote><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p>HTML 中的每一个元素都可以看成是一个盒子，可以通过多个属性来描述盒子的形状大小，从而可以非常灵活的改变样式</p></blockquote><!-- more --><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><blockquote><p>由四个主要属性组成</p></blockquote><ul><li>content 内容</li><li>padding 内边距</li><li>border 边框</li><li>margin 外边距</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="W3C-盒模型"><a href="#W3C-盒模型" class="headerlink" title="W3C 盒模型"></a>W3C 盒模型</h3><blockquote><p>W3C 盒模型规定代码中设定 width 为 content 部分大小，height 同理</p></blockquote><p>所以该盒模型实际占据的页面空间大小为 margin + border + padding + width(content)</p><blockquote><p>该模型的大小可以随着 content 的大小变化而变化</p></blockquote><h3 id="IE-盒模型"><a href="#IE-盒模型" class="headerlink" title="IE 盒模型"></a>IE 盒模型</h3><blockquote><p>IE 盒模型规定代码中设定 width 为 content + border + padding 部分大小，height 同理</p></blockquote><p>所以该盒模型实际占据的页面空间大小为 margin + 代码中设置的值 width(border + padding + content)</p><blockquote><p>该模型下，一旦父盒子确定，那么子盒子是无法将其撑开的</p></blockquote><ul><li>由此看来，在设置相同的 width 值时，W3C 盒模型明显要比 IE 盒模型大许多</li></ul><h2 id="margin-塌陷（重叠）"><a href="#margin-塌陷（重叠）" class="headerlink" title="margin 塌陷（重叠）"></a>margin 塌陷（重叠）</h2><blockquote><p>当垂直方向上的两个元素合并时，上面一个元素的 margin-bottom 和下面一个元素的 margin-top 不会叠加，而是取最大的那一个作为两个元素之间的距离</p></blockquote><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><blockquote><p>可以在上下两个元素或者任意一个元素外层套上一个 div，并设置 overflow: hidden;</p></blockquote><blockquote><p>可以只设置上面元素的 margin-bottom 值，大小为原定边距的两倍</p></blockquote><h1 id="动画方面animation和transition、过渡"><a href="#动画方面animation和transition、过渡" class="headerlink" title="动画方面animation和transition、过渡"></a>动画方面animation和transition、过渡</h1><h1 id="各种水平、垂直、水平垂直居中"><a href="#各种水平、垂直、水平垂直居中" class="headerlink" title="各种水平、垂直、水平垂直居中"></a>各种水平、垂直、水平垂直居中</h1><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="块状元素"><a href="#块状元素" class="headerlink" title="块状元素"></a>块状元素</h3><ul><li>margin: 0 auto; 上下间距为零，左右自适应</li></ul><h1 id="响应式布局实现方式"><a href="#响应式布局实现方式" class="headerlink" title="响应式布局实现方式"></a>响应式布局实现方式</h1><h1 id="伪元素和伪类元素"><a href="#伪元素和伪类元素" class="headerlink" title="伪元素和伪类元素"></a>伪元素和伪类元素</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;根据每个问题遇到的次数来进行排名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;层叠样式&quot;&gt;&lt;a href=&quot;#层叠样式&quot; class=&quot;headerlink&quot; title=&quot;层叠样式&quot;&gt;&lt;/a&gt;层叠样式&lt;/h1&gt;</summary>
    
    
    
    <category term="前端面经" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="CSS面经" scheme="http://example.com/tags/CSS%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
