<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="创建对象"><meta name="keywords" content="构造函数,原型"><meta name="author" content="Greatiga"><meta name="copyright" content="Greatiga"><title>创建对象 | Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '7.2.0'
} </script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%87%BD%E6%95%B0%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">当函数用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">理解原型对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype-isPrototypeOf"><span class="toc-number">3.1.1.</span> <span class="toc-text">prototype.isPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES5-%E6%96%B0%E5%A2%9E-Object-getPrototypeOf"><span class="toc-number">3.1.2.</span> <span class="toc-text">ES5 新增 Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%87%8D%E5%86%99%E5%92%8C-hasOwnProperty"><span class="toc-number">3.1.3.</span> <span class="toc-text">属性重写和 hasOwnProperty()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">in 操作符与原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-in-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.1.</span> <span class="toc-text">属性 in 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in"><span class="toc-number">3.2.2.</span> <span class="toc-text">for-in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-keys-%E5%92%8C-Object-getOwnPropertyNames"><span class="toc-number">3.2.3.</span> <span class="toc-text">Object.keys() 和 Object.getOwnPropertyNames()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E6%B4%81%E8%AF%AD%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">简洁语法和动态性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">原生对象的原型和原型存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.1.</span> <span class="toc-text">原生对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">构造函数和原型组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">寄生原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%B3%E5%A6%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.8.</span> <span class="toc-text">稳妥模式</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Greatiga</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">45</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">创建对象</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">面向对象的程序设计</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote>
<p>由于 ES6 之前没有 class 概念，所以使用函数来封装的，工程模式采用最直接的传入参数创建对象并赋值，然后返回对象的方式</p>
</blockquote>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o.<span class="property">name</span> = name;</span><br><span class="line">  o.<span class="property">age</span> = age;</span><br><span class="line">  o.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g1 = <span class="title class_">Great</span>(<span class="string">&#x27;link&#x27;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>(),g1.<span class="property">age</span>);<span class="comment">//link 21</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是工厂模式无法知道一个对象的类型</p>
</blockquote>
<h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><blockquote>
<p>使用 new 操作符，并且函数内部无需创建对象，也不需要 return 语句</p>
</blockquote>
<blockquote>
<p>使用 new 操作符会实行以下操作</p>
</blockquote>
<ul>
<li>当创建一个新对象时，将构造函数内部的 this 指向对象</li>
<li>执行代码将值赋值给该对象</li>
<li>返回这个对象</li>
</ul>
<blockquote>
<p>可以使用每个对象都拥有的属性 constructor 来检测其类型，也可以用 instanceof</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Bob&#x27;</span>,<span class="number">31</span>);</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>(),g1.<span class="property">age</span>);<span class="comment">//Bob 31</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">getName</span>(),g2.<span class="property">age</span>);<span class="comment">//Tom 27</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">constructor</span> == <span class="title class_">Great</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2 <span class="keyword">instanceof</span> <span class="title class_">Great</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="当函数用"><a href="#当函数用" class="headerlink" title="当函数用"></a>当函数用</h2><blockquote>
<p>本身构造函数也是函数，对于任何函数，使用 new 操作符来调用，就可以当做构造函数；按照普通函数那样调用也就更平常函数差不多</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>主要出现在对象的内部函数上，我们知道对象一般以堆内存的方法存储，也就是一堆变量和函数放在一堆，许多的对象就是许多这样的堆</p>
</blockquote>
<blockquote>
<p>对于构造函数里面定义的函数，创建的每个实例都拥有它，并且名字相同，看似这些函数都是同一个，其实不然，用上面一条来解释就知道，虽然他们拥有相同名字的函数，但是每个函数都在不同的堆里，互不影响。</p>
</blockquote>
<blockquote>
<p>问题就出在没必要每个实例都有这样的函数，毕竟调用函数时，都有每一个对象的 this 传入，依靠这个 this 就能确保调用函数时依据的是当前对象所拥有的值，不会冲突，所以他们其实可以共用一个，反正靠 this 指向就行。然而构造函数的方法就导致每个实例都有独自的函数，从而造成了大量内存浪费</p>
</blockquote>
<blockquote>
<p>此时可以使用一种方式解决</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = getName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Bob&#x27;</span>,<span class="number">31</span>);</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>());<span class="comment">//Bob</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">getName</span>());<span class="comment">//Tom</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过定义全局函数的方式，让他们共用一个</p>
</blockquote>
<blockquote>
<p>然而这样又出现一个问题，当函数较多时，全部放在外面，不就与普通函数搞混了吗，而且不好维护。所以，就此出现另一种模式，原型模式</p>
</blockquote>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><blockquote>
<p>问题引申：上面的构造函数说道，想要通过共同享用的方式来减少不必要的开销，但是太多的全局函数不利于和外部普通函数辨别，并且这也违背了封装的思想，所以原型就是允许以特殊的方式定义所有实例都可以共享的属性和方法，并且实例在共享的基础上还可以有属于自己的方法与属性</p>
</blockquote>
<blockquote>
<p>每一个函数包括构造函数，都有一个 prototype 属性，它是一个指针指向一个对象，该对象包含着特定类型的所有共享属性和方法</p>
</blockquote>
<blockquote>
<p><strong>无论是构造函数还是普通函数，反正只要是函数，都会默认创建一个 prototype 用来指向一个对象，也就是原型对象，而这个对象默认就有一个值，也就是 constructor，用来指向这个构造函数(函数)，所以这也是为什么一旦重写原型对象，就会导致 constructor 不在指向原来的构造函数，因为这个属性已经没有了</strong></p>
</blockquote>
<p>通常可以这么定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;原型-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">age</span>,g1.<span class="title function_">getName</span>())<span class="comment">//21 &quot;原型-&gt;Greatiga&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">getName</span> === g2.<span class="property">getName</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，上面的 getName 方法是共有的</p>
</blockquote>
<h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><ul>
<li>原型对象储存着所有实例都可以共享的属性和方法</li>
<li>所有的函数在创建时，都会根据一组特定规则创建一个 prototype 来指向函数数的原型对象</li>
<li>每一个原型对象又会拥有一个 constructor 用来指向定义该原型对象的函数</li>
<li>除此之外每个对象还拥有从 Object 继承而来的属性和方法</li>
<li>指向原型的指针叫 [[Prototype]]，但是没有标准的访问方式，可以靠 __proto__</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>每一个原型对象都有一个 constructor 属性指向构造它的构造函数</li>
<li>每一个构造函数有一个 prototype 属性指向它的原型对象，可以动态修改这个属性</li>
<li>每一个实例对象都有一个 [[Prototype]] 属性指向它所拥有的原型，通常不能直接访问修改，但可以通过 __proto__ 来查看</li>
</ul>
<h3 id="prototype-isPrototypeOf"><a href="#prototype-isPrototypeOf" class="headerlink" title="prototype.isPrototypeOf()"></a>prototype.isPrototypeOf()</h3><blockquote>
<p>用来测试一个对象的原型是否是来自于某个类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;原型-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GG</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable constant_">GG</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;no&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(g1))<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">GG</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(g2))<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="ES5-新增-Object-getPrototypeOf"><a href="#ES5-新增-Object-getPrototypeOf" class="headerlink" title="ES5 新增 Object.getPrototypeOf()"></a>ES5 新增 Object.getPrototypeOf()</h3><blockquote>
<p>用来获取实例的原型对象，该方法直接返回原型对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;原型-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(g1))<span class="comment">//&#123;name: &quot;Greatiga&quot;, age: 21, getName: ƒ, constructor: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性重写和-hasOwnProperty"><a href="#属性重写和-hasOwnProperty" class="headerlink" title="属性重写和 hasOwnProperty()"></a>属性重写和 hasOwnProperty()</h3><blockquote>
<p>除了添加新属性以外，实例也可以重写同名的属性和方法<br>重写不会影响原型中本就有的同名属性和方法<br>解析器执行实例时，会从实例自身开始找是否有符合的属性或方法，有就执行，否则就到原型中找<br>可以删除重写的属性或方法，这样就可以访问原型中的属性和方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;原型-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">g1.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;实例-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line">g2.<span class="property">name</span> = <span class="string">&#x27;Tomk&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>())<span class="comment">//实例-&gt;Greatiga</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">getName</span>())<span class="comment">//原型-&gt;Tomk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> g1.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>())<span class="comment">//原型-&gt;Greatiga</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过 hasOwnProperty() 方法测试一个属性来自于哪里，在实例中就为 true 否则为 false，这个方法是从 Object 那里继承而来的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;原型-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">g1.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;实例-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;getName&#x27;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="in-操作符与原型"><a href="#in-操作符与原型" class="headerlink" title="in 操作符与原型"></a>in 操作符与原型</h2><p>通常用在两个地方</p>
<blockquote>
<p>for-in 循环<br>属性 in 对象</p>
</blockquote>
<h3 id="属性-in-对象"><a href="#属性-in-对象" class="headerlink" title="属性 in 对象"></a>属性 in 对象</h3><blockquote>
<p>可以与 hasOwnProperty 组合使用来判断对象来自于实例还是原型</p>
</blockquote>
<ul>
<li>in可以先判断一个属性是否存在</li>
<li>通过 hasOwnProperty 又可以判断是否在实例中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">g1.<span class="property">name</span> = <span class="string">&#x27;Link&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> g1);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getName&#x27;</span> <span class="keyword">in</span> g1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((g1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) &amp;&amp; (<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> g1));<span class="comment">//true </span></span><br><span class="line"><span class="comment">//在实例中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((g1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;age&#x27;</span>)) &amp;&amp; (<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> g1))<span class="comment">//false </span></span><br><span class="line"><span class="comment">//在原型中</span></span><br></pre></td></tr></table></figure>

<h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><blockquote>
<p>我们应用在对象上时遍历出来的是属性名字</p>
</blockquote>
<ul>
<li>包括实例中所有属性</li>
<li>包括原型中所有属性</li>
<li>包括被标记为不可枚举的属性 Enumerable: false</li>
</ul>
<blockquote>
<p>上述条件的所有属性都会被遍历，IE8 之前的版本中，原型中被屏蔽不可枚举的属性无法被遍历，该问题在后续版本已修复</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">g1.<span class="property">area</span> = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line">g1.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (post <span class="keyword">in</span> g1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(post);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//area</span></span><br><span class="line"><span class="comment">//toString</span></span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-keys-和-Object-getOwnPropertyNames"><a href="#Object-keys-和-Object-getOwnPropertyNames" class="headerlink" title="Object.keys() 和 Object.getOwnPropertyNames()"></a>Object.keys() 和 Object.getOwnPropertyNames()</h3><blockquote>
<p>可以获得对象上所有可以枚举的属性，该方法返回一个数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">g1.<span class="property">area</span> = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line">g1.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>));<span class="comment">//(2) [&quot;name&quot;, &quot;age&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(g1));<span class="comment">//(2) [&quot;area&quot;, &quot;toString&quot;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，它会根据实例对象来确定遍历的属性，对象为原型就遍历原型，对象为实例对象就只遍历实例对象的属性</p>
</blockquote>
<blockquote>
<p>倘若要获取对象所有实例属性，则可以用 Object.getOwnPropertyNames()</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Greatiga&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line">g1.<span class="property">area</span> = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line">g1.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>));<span class="comment">//(3) [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">constructor</span> == <span class="title class_">Great</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="简洁语法和动态性"><a href="#简洁语法和动态性" class="headerlink" title="简洁语法和动态性"></a>简洁语法和动态性</h2><blockquote>
<p>原始定义原型的方式过于繁杂，可以简洁一点，但是这样的方式会导致 constructor 指向了 Object 而非构造函数，所以如果需要该值就得正确指定它的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  name : <span class="string">&#x27;Greatiga&#x27;</span>,</span><br><span class="line">  age : <span class="number">21</span>,</span><br><span class="line">  getName : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">constructor</span> == <span class="title class_">Great</span>);<span class="comment">//false</span></span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Great</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">constructor</span> == <span class="title class_">Great</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>动态性就是指修改原型对象的属性后能即使在实例中反映出来，无论该实例的创建是在修改前还是修改后，都有响应；原因很简单，实例执行时，解析器都会从当前对象找起，一直到原型对象，当然也就能响应了</p>
</blockquote>
<blockquote>
<p><strong>注意，修改原型对象时，不要用字面量的方式去修改，这会改变指针指向导致实例对象找不到原型。为什么呢？实例对象创建时会有一个属性(指针)指向原型对象，如果你只是修改原型中的对象那不会有事，因为你只是换了这堆砖头的一块砖，依然还是这堆砖，实例们依然可以找到</strong></p>
</blockquote>
<blockquote>
<p><strong>然而你直接用字面量方式去修改，就相当于弄了一堆新砖头，但是之前就已经有的实例对象还是指着原来那堆砖头并非你用字面量创建的新的一堆砖头，这不就导致该实例对象断开与原型的连接了吗，因为他现在存的那个指针值指向的不过是一堆没人要的砖头，说不定早就被当垃圾回收了呢</strong></p>
</blockquote>
<p>看下方例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  name : <span class="string">&#x27;Greatiga&#x27;</span>,</span><br><span class="line">  age : <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> <span class="title class_">Great</span>();</span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Great&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">name</span>);<span class="comment">//Great</span></span><br><span class="line"><span class="comment">//此时正常，因为依然还是这个原型对象</span></span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  name : <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  age : <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">name</span>);<span class="comment">//Great</span></span><br><span class="line"><span class="comment">//还是 Great?</span></span><br><span class="line">g.<span class="property">__proto__</span> = <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">name</span>);<span class="comment">//Tom</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>看上面倒数第三行那里，依然还是 Great 而不是 Tom，这并非程序错误，而是原型对象整个都变了，而实例 g 依然还是指着第一次改变名字后的那个原型对象，除非你改变实例 g 的指向，让它指向重写的那个原型对象，否则就永远找不到</p>
</blockquote>
<h2 id="原生对象的原型和原型存在的问题"><a href="#原生对象的原型和原型存在的问题" class="headerlink" title="原生对象的原型和原型存在的问题"></a>原生对象的原型和原型存在的问题</h2><h3 id="原生对象"><a href="#原生对象" class="headerlink" title="原生对象"></a>原生对象</h3><blockquote>
<p>比如 Array，String，Date，RegExp这些原生对象，他们也一样拥有原型对象，我们不仅可以访问这些原型对象，还可以给它增加新属性</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>);<span class="comment">//ƒ map() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toLocaleUpperCase</span>);<span class="comment">//ƒ toLocaleUpperCase() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getYear</span>);<span class="comment">//ƒ getYear() &#123; [native code] &#125;</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">printf</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">constructor</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">printf</span>);</span><br><span class="line"><span class="comment">//ƒ () &#123;</span></span><br><span class="line"><span class="comment">//  console.log(this.constructor)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Great&#x27;</span>.<span class="title function_">printf</span>());<span class="comment">//ƒ String() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><blockquote>
<p>第一个，因为所有属性都由原型定义好了，所有一创建实例，实例对象就拥有所有属性，有的时候没必要这样</p>
</blockquote>
<blockquote>
<p>第二，比较关键，就比如某个原型属性被改变了，那么其他所有实例都会改变，如果我们想要每个实例都有自己的属性，即使这些这些属性同名，也要有不同的值，而仅靠原型对象时无法实现的，因为他们都共享同一个。</p>
</blockquote>
<blockquote>
<p>怎么解决？回想之前的构造函数模式不就可以吗，只是当时我们想要共享属性所以抛弃了，但是现在我们想要一部分共享，一部分特有，这样一来就引出了组合模式</p>
</blockquote>
<h2 id="构造函数和原型组合模式"><a href="#构造函数和原型组合模式" class="headerlink" title="构造函数和原型组合模式"></a>构造函数和原型组合模式</h2><blockquote>
<p>组合这两种模式：构造函数模式定义实例可以独有的属性，原型模式定义所有实例共享的属性。这样一来，每个实例对象都有属于自己的实例属性，同时又可以共享部分共同的属性方法，从而最大限度节省了内存。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  time : <span class="string">&#x27;2020-01-01&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">setAge</span>: <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = s;</span><br><span class="line">  &#125;,</span><br><span class="line">  getAge : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Great&#x27;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Never&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>(), g1.<span class="title function_">getAge</span>());<span class="comment">//Great 21</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">time</span>);<span class="comment">//2020-01-01</span></span><br><span class="line">g2.<span class="title function_">setAge</span>(<span class="number">23</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">getName</span>(), g2.<span class="title function_">getAge</span>());<span class="comment">//Never 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="property">time</span>);<span class="comment">//2020-01-01</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上例子，两个对象拥有不同的名字和年龄，同时又共享一个时间</p>
</blockquote>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><blockquote>
<p>引入此概念也是为了更好的封装，我们知道字面量方式定义原型对象时往往是在构造函数外部。动态原型模式可以将原型的定义与构造模式的赋值一起放入构造函数内部，采用这种方式在内部定义时，不要使用字面量的方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Great</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">time</span> = <span class="string">&#x27;2020-01-01&#x27;</span>;</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setAge</span> = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = s;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Great</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Great&#x27;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> <span class="title class_">Great</span>(<span class="string">&#x27;Never&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">getName</span>(), g1.<span class="title function_">getAge</span>());<span class="comment">//Great 21</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="property">time</span>);<span class="comment">//2020-01-01</span></span><br><span class="line">g2.<span class="title function_">setAge</span>(<span class="number">23</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">getName</span>(), g2.<span class="title function_">getAge</span>());<span class="comment">//Never 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="property">time</span>);<span class="comment">//2020-01-01</span></span><br></pre></td></tr></table></figure>

<h2 id="寄生原型模式"><a href="#寄生原型模式" class="headerlink" title="寄生原型模式"></a>寄生原型模式</h2><blockquote>
<p>这一种模式旨在前面几种模式都无法使用的情况下使用，模式与普通的函数构造模式差不多，创建对象，赋值，返回对象，万不得已才用，而且红皮书上讲的也不是太细致，所以暂时不深究了</p>
</blockquote>
<h2 id="稳妥模式"><a href="#稳妥模式" class="headerlink" title="稳妥模式"></a>稳妥模式</h2><blockquote>
<p>在某些情境下，this 与 new 可能会不太安全，此时才用原有的创建对象、赋值、返回对象的方式来创建构造函数</p>
</blockquote>
<ul>
<li>不使用 this 创建实例属性，不使用 new 调用构造函数</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Greatiga</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/07/16/javaScript/createObject/">http://example.com/2020/07/16/javaScript/createObject/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">构造函数</a><a class="post-meta__tags" href="/tags/%E5%8E%9F%E5%9E%8B/">原型</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/17/javaScript/inheritance/"><i class="fa fa-chevron-left">  </i><span>面向对象的程序设计--继承</span></a></div><div class="next-post pull-right"><a href="/2020/07/15/computerNetwork/networkBasic/"><span>网络基础</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By Greatiga</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>